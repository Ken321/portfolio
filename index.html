<!doctype html>
<html lang="ja">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>20/80 Sidebar + 5×3 Grid — bottom nav + merged r3-right(1&2)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Noto+Sans+JP:wght@400;700&display=swap"
    rel="stylesheet">
  <style>
    /* page全体にSVGオーバーレイを敷くため */
    .page {
      position: relative;
    }

    /* ストローク層 */
    .svg-strokes {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      /* ラベル(.scene .label)より下/上は必要に応じて */
    }

    .svg-strokes path {
      fill: none;
      stroke: rgba(2, 75, 158, .45);
      stroke-width: 1;
      vector-effect: non-scaling-stroke;
      /* 常に1px */
      animation-name: draw-stroke;
      animation-timing-function: ease;
      animation-fill-mode: forwards;
    }

    @keyframes draw-stroke {
      to {
        stroke-dashoffset: 0;
      }
    }

    /* ラベルは線の上に出したい場合 */
    .scene .label {
      z-index: 2;
    }

    :root {
      --bg: #deefff;
      /* 背景 */
      --bg-elev: #deefff;
      /* セル面 */
      --text: #024b9e;
      /* 文字 */
      --muted: #024b9e;
      /* 補助文字 */
      --brand: #146EF5;
      /* アクセント */
      --subtle: #79afff;
      /* 薄め */
      --grid-gap: 0px;
      /* セル境界（WFC風の1pxリズム） */
      --cell-pad: 0;
      --radius: 14px;
      --mobile-header-height: 68px;
      --mobile-row-height: calc((100dvh - var(--mobile-header-height)) / 3);
    }

    * {
      box-sizing: border-box
    }

    html,
    body {
      height: 100%;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      margin: 0;
      font-family: Inter, "Noto Sans JP", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: var(--bg);
      color: var(--text)
    }

    body.scene-overlay-open {
      overflow: hidden;
    }

    a {
      color: inherit;
      text-decoration: none
    }

    /* ===== 20/80 レイアウト骨組み ===== */
    .page {
      display: flex;
      min-height: 100vh
    }

    .sidebar {
      width: 20%;
      background: #deefff;
    }

    .sidebar__inner {
      position: sticky;
      top: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      gap: 24px;
      padding: 0
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 800;
      padding: 24px;
    }

    .logo img {
      height: 56px;
    }

    .mobile-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      width: 100%;
      background: rgba(222, 239, 255, 0.95);
      padding-top: constant(safe-area-inset-top);
      padding-top: env(safe-area-inset-top);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      z-index: 100;
      display: none;
      border-bottom: 1px solid rgba(2, 75, 158, 0.08);
    }

    .mobile-header__inner {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 20px;
    }

    .mobile-header__logo img {
      height: 40px;
    }

    .mobile-header__menu {
      appearance: none;
      border: none;
      background: transparent;
      width: 44px;
      height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      cursor: pointer;
    }

    .mobile-header__burger,
    .mobile-header__burger::before,
    .mobile-header__burger::after {
      content: '';
      display: block;
      width: 26px;
      height: 2px;
      border-radius: 999px;
      background: #024b9e;
      transition: transform 0.3s ease, opacity 0.3s ease;
    }

    .mobile-header__burger::before {
      transform: translateY(-7px);
    }

    .mobile-header__burger::after {
      transform: translateY(7px);
    }

    body.mobile-drawer-open .mobile-header__burger {
      background: transparent;
    }

    body.mobile-drawer-open .mobile-header__burger::before {
      transform: translateY(0) rotate(45deg);
    }

    body.mobile-drawer-open .mobile-header__burger::after {
      transform: translateY(0) rotate(-45deg);
    }

    .mobile-drawer {
      position: fixed;
      inset: 0;
      display: none;
      z-index: 90;
      pointer-events: none;
    }

    .mobile-drawer__overlay {
      position: absolute;
      inset: 0;
      background: rgba(2, 36, 78, 0.35);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .mobile-drawer__panel {
      position: absolute;
      top: 0;
      right: 0;
      width: min(280px, 80vw);
      height: 100%;
      background: rgba(222, 239, 255, 0.95);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      padding: 100px 32px;
      display: flex;
      flex-direction: column;
      gap: 18px;
      transform: translateX(100%);
      transition: transform 0.3s ease;
      box-shadow: -6px 0 24px rgba(2, 75, 158, 0.15);
    }

    .mobile-drawer__link {
      font-size: 1.2rem;
      color: #024b9e;
      text-decoration: none;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    body.mobile-drawer-open {
      overflow: hidden;
    }

    body.mobile-drawer-open .mobile-drawer__overlay {
      opacity: 1;
    }

    body.mobile-drawer-open .mobile-drawer__panel {
      transform: translateX(0);
    }

    body.mobile-drawer-open .mobile-drawer {
      pointer-events: auto;
    }


    .nav {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: auto
    }

    /* ← 下揃え */
    .nav a {
      color: var(--muted);
      padding: 16px;
      font-size: 1.3rem;
    }

    .nav a:hover {
      color: #024b9e;
      background: rgba(2, 75, 158, .1)
    }

    .main {
      width: 80%;
      position: relative;
      transition: width 2s cubic-bezier(.22, .8, .25, 1);
    }

    /* ===== 5×3 グリッド ===== */
    .grid5x3 {
      display: grid;
      gap: var(--grid-gap);
      background: rgba(255, 255, 255, .06);
      grid-template-columns: repeat(5, 1fr);
      grid-template-rows: repeat(3, calc(100vh / 3));
      grid-auto-rows: calc(100vh / 3);
      transition: none;
      /* 追加行も同じ高さに */
    }

    .cell {
      background: transparent;
      position: relative;
      padding: var(--cell-pad);
      border-radius: 0;
      min-width: 0;
      min-height: 0;
      overflow: hidden;
      transition: box-shadow 0.5s ease, border-radius 0.5s ease, background 0.5s ease,
        transform 3s cubic-bezier(.22, .8, .25, 1);
    }

    .cell.hero {
      padding: 24px;
    }

    .cell>img {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .cell-inner {
      background: #e6f4ff;
      width: calc(100% - 48px);
      height: calc(100% - 48px);
      padding: 24px;
      margin: 24px;
    }

    .cell-inner_title {
      margin: 0 0 .4em;
      font-size: clamp(22px, 3.2vw, 32px);
      font-weight: 800;
      text-transform: uppercase;
    }

    .cell-inner_description {
      color: var(--muted);
      line-height: 1.6;
      letter-spacing: 0.1em;
    }



    /* ヒーロー：左から3・上から3（=3col×3row 結合） */
    .hero {
      grid-column: 1 / span 3;
      grid-row: 1 / span 3;
      display: flex;
      flex-direction: column;
      justify-content: flex-end
    }

    .kicker {
      color: var(--muted);
      font-weight: 800;
      letter-spacing: 0.1em;
      font-size: 1rem;
      text-transform: uppercase;
    }

    .h1 {
      font-weight: 800;
      font-size: clamp(28px, 5vw, 48px);
      line-height: 1.08;
      margin: .4em 0
    }

    .h1 span {
      font-size: clamp(56px, 10vw, 128px);
    }

    .lead {
      color: var(--muted);
      font-size: 1.1rem;
      line-height: 1.5;
      letter-spacing: 0.3em;
    }

    /* セクション（About/Contact）は全幅1セル） */
    .section {
      grid-column: 1 / -1
    }

    /* シーンセル（残りの各セルに three.js を描画） */
    .scene {
      padding: 0;
      overflow: hidden;
      position: relative;
      transition: border-radius 0.5s ease, box-shadow 0.5s ease, transform 0.5s cubic-bezier(.22, .8, .25, 1),
        opacity 0.5s ease;
      will-change: transform, opacity;
      transform: translate3d(0, 0, 0);
    }

    .scene--expandable {
      cursor: pointer;
    }

    .scene--floating {
      box-shadow: 0 28px 60px rgba(2, 75, 158, .22);
      border-radius: calc(var(--radius) * 1.2);
    }

    .scene--expanded {
      border-radius: 0;
      background: rgba(2, 17, 32, .85);
      z-index: 200;
    }

    .scene.scene--detail-open {
      z-index: 60;
    }

    .scene::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(185deg, rgba(2, 75, 158, .25) 0%, rgba(1, 3, 9, .68) 60%);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.4s ease 0.2s, transform 0.4s ease 0.2s;
      z-index: 2;
    }

    .scene::after {
      content: "";
      position: absolute;
      inset: 0;
      background: var(--bg);
      opacity: 0;
      transition: opacity 0.5s ease;
      pointer-events: none;
      z-index: 1;
    }

    .scene--expanded::before {
      opacity: 1;
      transform: scale(1.02);
    }

    .scene--expanded::after {
      opacity: 0;
    }

    .scene__details {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      gap: clamp(16px, 4vw, 32px);
      padding: clamp(24px, 5vw, 64px);
      color: #fff;
      pointer-events: none;
      opacity: 0;
      z-index: 3;
      background: linear-gradient(180deg, rgba(6, 20, 37, 0) 20%, rgba(0, 9, 20, 0.82) 100%);
      transition: opacity 0.4s ease 0.2s;
    }

    .scene--expanded .scene__details {
      opacity: 1;
      pointer-events: auto;
    }

    .scene__details-body {
      max-width: min(960px, 90%);
      display: flex;
      flex-direction: column;
      gap: clamp(16px, 3vw, 28px);
    }

    .scene__detail-overlay {
      position: absolute;
      inset: 0;
      padding: clamp(24px, 6vw, 96px);
      display: flex;
      flex-direction: column;
      gap: clamp(16px, 3vw, 32px);
      background: transparent;
      color: #024b9e;
      opacity: 0;
      pointer-events: none;
      transform: translateY(24px);
      transition: opacity 0.4s ease, transform 0.4s ease;
      overflow: auto;
      z-index: 210;
    }

    .scene__detail-overlay::-webkit-scrollbar {
      width: 10px;
    }

    .scene__detail-overlay::-webkit-scrollbar-thumb {
      background: rgba(2, 75, 158, 0.25);
      border-radius: 999px;
    }

    .scene--detail-open .scene__detail-overlay {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }

    .scene__detail-body {
      display: flex;
      flex-direction: column;
      gap: clamp(12px, 2vw, 20px);
      width: 100%;
      height: 100%;
    }

    .scene--detail-open .scene__detail-body {
      height: auto;
    }

    .scene__detail-title {
      margin: 0;
      display: inline-block;
      align-self: flex-start;
      width: fit-content;
      font-size: clamp(40px, 10vw, 80px);
      font-weight: 800;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      background: #fff;
    }

    .scene__detail-text {
      margin: 0;
      display: inline-block;
      align-self: flex-start;
      width: fit-content;
      font-size: clamp(14px, 2.2vw, 18px);
      line-height: 1.7;
      color: rgba(2, 75, 158, 0.85);
      background: #fff;
      padding: 0.25em 0.75em;
    }

    .scene__detail-text a {
      color: var(--subtle);
    }

    .scene__detail-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    .scene__detail-link,
    .scene__detail-close {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.6rem 1.8rem;
      border-radius: 999px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 0.85rem;
      border: none;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, color 0.2s ease;
    }

    .scene__detail-link {
      background: #024b9e;
      color: #fff;
      text-decoration: none;
      box-shadow: 0 10px 24px rgba(2, 75, 158, 0.32);
    }

    .scene__detail-link:hover,
    .scene__detail-link:focus-visible {
      transform: translateY(-2px);
      background: #146ef5;
      box-shadow: 0 14px 32px rgba(20, 110, 245, 0.35);
    }

    .scene__detail-close {
      background: rgba(255, 255, 255, 1);
      color: #024b9e;
      box-shadow: 0 6px 16px rgba(2, 75, 158, 0.12);
    }

    .scene__detail-close:hover,
    .scene__detail-close:focus-visible {
      transform: translateY(-2px);
      box-shadow: 0 10px 22px rgba(2, 75, 158, 0.2);
    }

    .scene--borderless {
      background: transparent;
      box-shadow: none;
      border-radius: 0;
    }

    .scene.scene--borderless::before {
      opacity: 0;
    }

    .scene__details h3 {
      margin: 0;
      font-size: clamp(28px, 6vw, 48px);
      font-weight: 800;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .scene__details p {
      margin: 0;
      max-width: min(640px, 70%);
      font-size: clamp(14px, 2.4vw, 18px);
      line-height: 1.7;
      letter-spacing: 0.06em;
      color: rgba(230, 242, 255, 0.9);
    }

    .scene__actions {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      align-items: center;
    }

    .scene__link,
    .scene__close {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 0.75em 1.4em;
      font-size: 0.9rem;
      font-weight: 700;
      text-transform: uppercase;
      border-radius: 999px;
      border: 0;
      cursor: pointer;
      transition: transform 0.25s ease, background 0.25s ease, color 0.25s ease;
      letter-spacing: 0.08em;
    }

    .scene__link {
      background: #146EF5;
      color: #fff;
    }

    .scene__link:hover,
    .scene__link:focus-visible {
      background: #2f7df6;
      transform: translateY(-2px);
    }

    .scene__close {
      background: rgba(222, 239, 255, 0.16);
      color: #deefff;
    }

    .scene__close:hover,
    .scene__close:focus-visible {
      background: rgba(222, 239, 255, 0.28);
      transform: translateY(-2px);
    }

    .scene__close {
      border: 1px solid rgba(222, 239, 255, 0.32);
    }

    .scene .label {
      position: absolute;
      left: 10px;
      bottom: 10px;
      padding: .4rem .6rem;
      border-radius: 10px;
      background: rgba(0, 0, 0, .45);
      font-weight: 700;
      font-size: 12px
    }

    .scene iframe {
      display: block;
      width: 100%;
      height: 100%;
      border: 0;
    }

    #scene-2,
    #scene-3,
    #scene-4,
    #scene-5,
    #scene-7,
    #scene-8,
    #scene-9,
    #scene-10,
    #scene-11,
    #scene-12,
    #scene-13,
    #scene-14,
    #scene-21,
    #contact-curtain {
      user-select: none;
      -webkit-user-select: none;
    }

    #scene-21:hover {
      cursor: pointer;
    }

    .scene3-matrix {
      position: absolute;
      inset: 0;
      pointer-events: auto;
    }

    .scene3-matrix canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #scene-5 {
      background: #deefff;
    }

    /* 座標ユーティリティ（初期6枠のうち5枠＋結合1枠を明示配置） */
    .c4 {
      grid-column: 4
    }

    .c5 {
      grid-column: 5
    }

    .r1 {
      grid-row: 1
    }

    .r2 {
      grid-row: 2
    }

    .r3 {
      grid-row: 3
    }

    /* 3行目 右2セルを結合（= 4-5列を横断） */
    .merge-r3-right12 {
      grid-column: 4 / span 2;
      grid-row: 3;
    }

    /* 4行目 左2セルを結合（= 1-2列を横断） */
    .merge-r4-left12 {
      grid-column: 1 / span 2;
      grid-row: 4;
    }

    #scene-6 {
      overflow: hidden;
    }

    #scene-6 .cell-inner {
      transition: opacity 0.4s ease;
    }

    #scene-6.scene-info--hidden {
      pointer-events: none;
    }

    #scene-6.scene-info--hidden .cell-inner {
      opacity: 0;
      visibility: hidden;
    }

    /* 6行目 左2セルを結合（= 1-2列を横断、2行分の高さ） */
    .merge-r5-left12 {
      grid-column: 1 / span 2;
      grid-row: 6 / span 2;
    }

    /* 6行目 右3セルを結合（= 3-5列を横断、2行分の高さ） */
    .merge-r5-right345 {
      grid-column: 3 / span 3;
      grid-row: 6 / span 2;
    }

    /* 6行目 全5列を結合（= 1-5列を横断） */
    .merge-r6-all {
      grid-column: 1 / -1;
      grid-row: 6;
    }

    /* Responsive */
    @media (max-width: 900px) {
      :root {
        --mobile-header-height: calc(68px + env(safe-area-inset-top));
        --mobile-row-height: calc((100dvh - var(--mobile-header-height)) / 3);
      }

      .mobile-header {
        display: block;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
      }

      .mobile-drawer {
        display: block;
      }

      .page {
        flex-direction: column;
        min-height: 100svh;
        padding-top: var(--mobile-header-height);
      }

      .sidebar {
        display: none;
      }

      .main {
        width: 100%;
      }

      .sidebar__inner {
        height: auto;
        position: relative;
      }

      .grid5x3 {
        grid-template-columns: repeat(3, minmax(0, 1fr));
        grid-template-rows: repeat(3, var(--mobile-row-height));
        grid-auto-rows: var(--mobile-row-height);
        grid-auto-flow: row dense;
        gap: 0;
        padding: 0;
      }

      .grid5x3>.cell {
        height: var(--mobile-row-height);
        min-height: var(--mobile-row-height);
      }

      .scene {
        transform: none;
        will-change: auto;
      }

      #top {
        grid-column: 1 / span 2;
        grid-row: 1 / span 3;
        height: calc(var(--mobile-row-height) * 3);
        min-height: calc(var(--mobile-row-height) * 3);
      }

      #scene-1 {
        grid-column: 3;
        grid-row: 1;
      }

      #scene-2 {
        grid-column: 3;
        grid-row: 2;
      }

      #scene-3 {
        grid-column: 3;
        grid-row: 3;
      }

      #scene-5 {
        grid-column: 1 / span 3;
        grid-row: 4;
      }

      #scene-6 {
        grid-column: 1 / span 3;
        grid-row: 5;
      }

      #scene-7 {
        grid-column: 1;
        grid-row: 6;
      }

      #scene-8 {
        grid-column: 2;
        grid-row: 6;
      }

      #scene-9 {
        grid-column: 3;
        grid-row: 6;
      }

      #scene-10 {
        grid-column: 1;
        grid-row: 7;
      }

      #scene-11 {
        grid-column: 2;
        grid-row: 7;
      }

      #scene-12 {
        grid-column: 3;
        grid-row: 7;
      }

      #scene-13 {
        grid-column: 1;
        grid-row: 8;
      }

      #scene-14 {
        grid-column: 2 / span 2;
        grid-row: 8;
      }

      #scene-21 {
        grid-column: 1 / span 3;
        grid-row: 9 / span 2;
        height: calc(var(--mobile-row-height) * 2);
        min-height: calc(var(--mobile-row-height) * 2);
      }

      #scene-23 {
        grid-column: 1 / span 3;
        grid-row: 11 / span 2;
        /* ★ 9から11に変更 */
        height: calc(var(--mobile-row-height) * 2);
        min-height: calc(var(--mobile-row-height) * 2);
      }

      #contact {
        grid-column: 1 / span 3;
        grid-row: 13;
        /* ★ 11から13に変更 */
        height: var(--mobile-row-height);
        min-height: var(--mobile-row-height);
      }

      #scene-4 {
        display: none;
      }

      body.scene-overlay-open .grid5x3>.cell {
        height: auto;
        min-height: 0;
      }

      body.scene-overlay-open #scene-21,
      body.scene-overlay-open #scene-23,
      body.scene-overlay-open #contact {
        height: auto;
        min-height: 0;
      }

      body.scene-overlay-open .scene--detail-open .scene__detail-overlay {
        position: fixed;
        top: var(--mobile-header-height);
        left: 0;
        right: 0;
        bottom: 0;
        padding: 32px clamp(18px, 6vw, 36px) calc(32px + env(safe-area-inset-bottom));
        margin: 0;
        max-width: 100%;
        color: #deefff;
        overflow-y: auto;
      }

      body.scene-overlay-open .scene--detail-open .scene__detail-title,
      body.scene-overlay-open .scene--detail-open .scene__detail-text {
        color: #024b9e;
      }

      body.scene-overlay-open .scene--detail-open .scene__detail-text {
        /* color: rgba(222, 239, 255, 0.9); */
      }

      body.scene-overlay-open .scene--detail-open .scene__detail-body {
        padding-top: 0;
      }
    }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <header class="mobile-header">
    <div class="mobile-header__inner">
      <a class="mobile-header__logo" href="#top">
        <img src="./321ken_logo.svg" alt="321ken logo">
      </a>
      <button class="mobile-header__menu" type="button" aria-expanded="false" aria-controls="mobile-drawer-panel"
        aria-label="Toggle navigation">
        <span class="mobile-header__burger"></span>
      </button>
    </div>
  </header>

  <nav class="mobile-drawer" aria-hidden="true">
    <div class="mobile-drawer__overlay" role="presentation"></div>
    <div class="mobile-drawer__panel" id="mobile-drawer-panel">
      <a class="mobile-drawer__link" href="#top">Top</a>
      <a class="mobile-drawer__link" href="#scene-23">About</a>
      <a class="mobile-drawer__link" href="#contact">Contact</a>
    </div>
  </nav>

  <div class="page">
    <!-- 20% 固定サイドバー（Bottom aligned: Top / About / Contact） -->
    <aside class="sidebar">
      <div class="sidebar__inner">
        <div class="logo"><img src="./321ken_logo.svg" alt="321ken logo"></div>
        <nav class="nav" aria-label="ページ内リンク">
          <a href="#top">Top</a>
          <a href="#scene-23">About</a>
          <a href="#contact">Contact</a>
        </nav>
      </div>
    </aside>

    <!-- 80% メイン（通常スクロール、5×3 グリッド） -->
    <main class="main" aria-label="メインコンテンツ">
      <section class="grid5x3">
        <!-- 結合セル：左3×上3（タイトル＆概要） -->
        <header id="top" class="cell hero">
          <div class="kicker">PORTFOLIO</div>
          <h1 class="h1"><span>321ken</span><br>UI/UX Designer & Frontend Engineer</h1>
          <p class="lead">Seamlessly transitioning between design and coding, I transform ideas into products.<br>
            As an amateur, I explore the possibilities of UI/UX in AR.</p>
        </header>

        <!-- 明示配置：r1, r2（右2列）＋ r3 は右2列を結合して1セル -->
        <article id="scene-1" class="cell scene c4 r1" data-effect="number3"></article>
        <article id="scene-2" class="cell scene c5 r1" data-effect="noiseField"></article>
        <article id="scene-3" class="cell scene c4 r2" data-effect="halftoneOne"></article>
        <article id="scene-4" class="cell scene c5 r2" data-effect="waves"></article>
        <!-- r3: 右から1&2（= 5列目+4列目）を 1セルへ結合 -->
        <article id="scene-5" class="cell scene merge-r3-right12" data-effect="rapierSwarm"></article>

        <!-- 以下、自動配置：5×n の行に Scene 6〜36 を流し込み（行高は 100vh/3 を維持） -->
        <!-- 6-12 -->
        <article id="scene-6" class="cell merge-r4-left12">
          <div class="cell-inner">
            <h2 class="cell-inner_title">What I made</h2>
            <p class="cell-inner_description">
              I've primarily built Web AR using 8th Wall. I previously developed iOS AR apps using Unity, but I've
              mostly forgotten how.
            </p>
          </div>
        </article>
        <!-- 4行目 右3セル -->
        <article id="scene-7" class="cell scene" data-effect="image" data-img="./img/tenori_friends.png"
          data-title="TENORI Friends" data-description='This project imagines what communication platforms like Slack or LINE might look like in AR.<br>
          Your connected friend appears as a tiny avatar wandering around a miniature room. Even when your friend isn’t online, the avatar might still talk about the weather in their location (I originally wanted it to display their latest posts from X as well). When they log in, you can chat through their avatar — ideally, I wanted to enable voice conversations too.<br>
          
          Since it’s built with 8th Wall, no download is required. Real-time synchronization between connected users is handled using 8th Wall’s Shared AR Module.<br>
          Because I’m using the Starter plan, there’s a UX limitation: users can’t directly open the experience from the invitation QR code. Oddly enough, opening the same QR code twice seems to make it work.<br>
          Built with: 8th Wall (A-Frame)' data-link="https://youtu.be/-SKVXbq8gUs?si=SsdnsV43orP-6hph"
          data-link-label="Watch on YouTube">
          <!-- <div class="scene__detail-template">
            <h3>TENORI Friends</h3>
            <p>WebAR rhythm experience where characters react to the performance and invite the audience to play together.</p>
            <a href="https://youtu.be/-SKVXbq8gUs?si=SsdnsV43orP-6hph" target="_blank" rel="noopener noreferrer">Watch on YouTube</a>
          </div> -->
        </article>
        <article id="scene-8" class="cell scene" data-effect="image" data-img="./img/bugssymphony.jpg"
          data-title="Bugs Symphony" data-description='A location-based AR game created for <a href="https://www.8thwall.com/blog/post/172638605886/meet-the-winners-explore-together-challenge" target="_blank" rel="noopener noreferrer">The Explore Together Challenge</a>.
          The goal is to complete a symphony by collecting special musical bugs scattered around the world.<br><br>
          You can play it anywhere that supports Niantic VPS Wayspots — by retrieving the 3D mesh of the location, butterflies and dragonflies appear perched across the ground and walls. As you approach them, they flutter away. Their flocking behavior is calculated using the Boids algorithm via GPUComputationRenderer.<br>
          The special target bugs emit sounds using PositionalAudio, so with headphones, you can locate them by ear — you could almost play with your eyes closed by following the direction of the sound.<br>
          Since AR games are inherently spatial, I wanted to explore how sound direction could be used as an essential part of gameplay rather than just a background element.<br>
          I personally thought it was a masterpiece — but it ended up as a Nature Navigator Prize Winner.<br>
          Built with: 8th Wall (Three.js)' data-link="https://www.8thwall.com/bench/location-based-ar"
          data-link-label="Launch on 8th Wall">
        </article>
        <article id="scene-9" class="cell scene" data-effect="image" data-img="./img/kamizumo.png"
          data-title="AR Kami-Zumo" data-description='This project reimagines “Kami Sumo,” a traditional Japanese tabletop wrestling game, in augmented reality.<br>
          When you tap the virtual buttons placed on a real table, paper-like sumo wrestlers shake and move as if reacting to the table itself being hit. This makes the experience surprisingly tactile and physically believable for AR.<br>
          Most AR interfaces tend to rely on floating virtual buttons in space — something you tap with no physical feedback. Personally, I find that lack of touch very unsatisfying. By projecting UI onto real surfaces, at least you can feel the object beneath it. That simple contact adds a sense of reality and usability that purely virtual interfaces often lack.<br>
          It’s like typing on an invisible keyboard in the air versus one projected onto your desk — the latter feels almost real.<br>
          This was actually my very first AR project. Despite being just a small game, it ended up weighing a hefty 500 MB… a big flaw, but also a good lesson.<br>
          Built with: Unity, AR Foundation, MediaPipe (MediaPipeUnityPlugin)'
          data-link="https://youtu.be/nF4E8MjyVu8?si=C9Tpxh7yzLl8rq2K" data-link-label="Watch on YouTube">

        </article>

        <!-- 5行目 全5セル（What I madeの下） -->
        <article id="scene-10" class="cell scene" data-effect="image" data-img="./img/meishi.png"
          data-title="AR Business Card" data-description='I work as a UI/UX designer at a company called Bench, and this project turns my business card into an AR mini-game.<br>
          By using image tracking, the experience gives the illusion that the AR elements physically interact with the real card itself. There are three playful modes:<br>
          Greeting CEO – Our CEO appears standing on the card and greets you. Tilt the card, and he loses balance and falls off.<br>
          Lifting CEO – You can juggle a curled-up version of the CEO right on top of the card.<br>
          Maze Game – A two-story maze appears above the card. By tilting the business card, you can roll the curled-up CEO through the maze to reach the goal.<br>
          It’s a lighthearted project exploring how AR can blend physical touch and humor — transforming a simple business card into an interactive playground.<br>
          Built with: Unity, AR Foundation' data-link="https://x.com/321kn/status/1541271768639238144" data-link-label="Watch on x">

        </article>
        <article id="scene-11" class="cell scene" data-effect="image" data-img="./img/haiti.png"
          data-title="Hope for Haiti" data-description='An AR experience created for <a href="https://www.8thwall.com/blog/post/145396566051/meet-the-winners-8thwall-hopeforhaiti" target="_blank" rel="noopener noreferrer">The 8th Wall × Hope for Haiti Challenge</a>.<br>
          In front of the user hangs a translucent screen displaying information and videos about Hope for Haiti.<br>
          As you push through the screens and move forward, the experience invites you to feel as if you’re walking into the story itself.<br>
          While you read and explore, hibiscus flowers — which bloom abundantly in Haiti — begin to blossom at your feet.<br>
          When you finish viewing all of the content, hibiscus petals gently fall from the sky, symbolizing hope and renewal.<br>
          Built with: 8th Wall (Three.js)' data-link="https://www.8thwall.com/bench/hope-for-haiti-challenge"
          data-link-label="Open on 8th Wall">

        </article>
        <article id="scene-12" class="cell scene" data-effect="image" data-img="./img/nanach.png" data-title="NanAR"
          data-description='An AR experience created with 8th Wall, designed for Bench’s engineering team business cards.<br>
          I’ve always loved the idea of “portals” in AR — looking into another world through a window in reality.<br>
          In this project, the business card itself becomes that portal, and an avatar emerges from it to introduce themselves.<br>
          By rolling a virtual die, you trigger the avatar to answer a question corresponding to the number that appears.<br>
          Each roll leads to a slightly different self-introduction, making the experience playful and personal — like a tiny conversation through another dimension.<br>
          Built with: 8th Wall (Three.js)' data-link="https://www.8thwall.com/bench/nanar"
          data-link-label="Open on 8th Wall">

        </article>
        <article id="scene-13" class="cell scene" data-effect="image" data-img="./img/pyisic-simulation.png"
          data-title="Physics Simulation" data-description='A custom 8th Wall module created for <a href="https://www.8thwall.com/blog/post/125806910635/meet-the-winners-of-the-modules-challenge" target="_blank" rel="noopener noreferrer">The Modules Challenge</a>.<br>
          This module integrates Ammo.js into 8th Wall in a way that makes it easier to use within AR projects.<br>
          It enables soft-body physics simulations and detailed constraint control, expanding the expressive possibilities of real-world physics in augmented reality.<br>
          I believe this opened up new ways to blend physical realism with interactive AR experiences — a foundation for more tactile and believable virtual worlds.<br>
          The project was awarded the Grand Prize.<br>
          Built with: 8th Wall (Three.js)'
          data-link="https://www.8thwall.com/bench/physics-simmulation-in-threejs-sample"
          data-link-label="Launch on 8th Wall">

        </article>
        <article id="scene-14" class="cell scene" data-effect="image" data-img="./img/light_bird.png"
          data-title="Light Birds" data-description='An AR experience where glowing birds flock and gather around your fingertips.<br>
          Before creating BUGS SYMPHONY, I wanted to experiment with GPUComputationRenderer, so I built this piece as a technical exploration.<br>
          The flocking behavior is driven by the Boids algorithm, computed entirely on the GPU.<br>
          By feeding the hand mesh captured from AR into the same computation, the interaction became dramatically more responsive and lifelike — as if the birds truly sensed and reacted to your movements in real space.<br>
          Built with: 8th Wall (Three.js)' data-link="https://www.8thwall.com/bench/gpgpu-postprocess-example"
          data-link-label="Launch on 8th Wall">

        </article>

        <!-- 6行目 プロフィールとAbout（2行分の高さ） -->
        <article id="scene-21" class="cell scene merge-r5-left12" data-effect="avatar">
        </article>
        <article id="scene-23" class="cell merge-r5-right345" style="overflow:hidden;">
          <div class="cell-inner">
            <h2 class="cell-inner_title">About</h2>
            <p class="cell-inner_description">
              I work as a designer at Bench Inc., where I’m mainly responsible for UI/UX design of business systems.<br>
              As an amateur creator, I’ve produced several AR projects and have won multiple awards in 8th Wall’s
              challenges.<br>
              <br>
              I enjoy thinking across different domains—how AR can improve the world, what UI design in AR should look
              like, and what’s
              technically possible at AR development.
            </p>
          </div>
        </article>

        <!-- About / Contact セクション（全幅セル） -->
        <article id="contact" class="cell scene section" data-effect="contactCurtain"></article>

      </section>
    </main>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.168.0/build/three.module.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.168.0/examples/jsm/loaders/GLTFLoader.js';
    import { FontLoader } from 'https://unpkg.com/three@0.168.0/examples/jsm/loaders/FontLoader.js';
    import { TextGeometry } from 'https://unpkg.com/three@0.168.0/examples/jsm/geometries/TextGeometry.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.168.0/examples/jsm/controls/OrbitControls.js';
    import { EffectComposer } from 'https://unpkg.com/three@0.168.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.168.0/examples/jsm/postprocessing/RenderPass.js';
    import { ShaderPass } from 'https://unpkg.com/three@0.168.0/examples/jsm/postprocessing/ShaderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three@0.168.0/examples/jsm/postprocessing/UnrealBloomPass.js';

    class AsciiEffect {

      constructor(renderer, charSet = ' .:-=+*#%@', options = {}) {

        const STAGE_COUNT = 3;
        const STAGE_STEPS = 100;
        const clamp01 = (v) => v < 0 ? 0 : (v > 1 ? 1 : v);
        const hash01 = (seed) => {
          const s = Math.sin(seed * 12.9898 + 78.233);
          return s - Math.floor(s);
        };

        const fResolution = options['resolution'] || 0.15;
        const iScale = options['scale'] || 1;
        const bColor = options['color'] || false;
        const bAlpha = options['alpha'] || false;
        const bBlock = options['block'] || false;
        const bInvert = options['invert'] || false;
        const strResolution = options['strResolution'] || 'low';
        const palette = Array.isArray(options.colorPalette) && options.colorPalette.length > 0
          ? options.colorPalette
          : ['#024b9e', '#217adf', '#72b4ff'];

        let asciiCellCount = 0;
        let stageThresholds = null;
        let asciiWidthCells = 0;
        let asciiHeightCells = 0;
        let transitionProgress = 0;
        const stageReplacementChars = Array.isArray(options.stageReplacementChars)
          ? options.stageReplacementChars
          : ['2', '1', '0'];

        let width, height;
        let lastSetWidth = null;
        let lastSetHeight = null;

        const domElement = document.createElement('div');
        domElement.style.cursor = 'default';

        const oAscii = document.createElement('table');
        domElement.appendChild(oAscii);

        let iWidth, iHeight;
        let oImg;

        this.setSize = function (w, h) {

          width = w;
          height = h;

          if (w <= 0 || h <= 0) {
            renderer.setSize(Math.max(1, w || 1), Math.max(1, h || 1));
            iWidth = 0;
            iHeight = 0;
            return;
          }

          renderer.setSize(w, h);

          if (stageThresholds === null || w !== lastSetWidth || h !== lastSetHeight) {
            lastSetWidth = w;
            lastSetHeight = h;
            initAsciiSize();
          }

        };


        this.render = function (scene, camera) {

          if (width <= 0 || height <= 0 || iWidth <= 0 || iHeight <= 0) return;
          renderer.render(scene, camera);
          asciifyImage(oAscii);

        };

        this.domElement = domElement;

        this.setTransitionProgress = function (value) {
          transitionProgress = clamp01(value || 0);
        };


        function initAsciiSize() {

          iWidth = Math.max(1, Math.floor(width * fResolution));
          iHeight = Math.max(1, Math.floor(height * fResolution));

          oCanvas.width = iWidth;
          oCanvas.height = iHeight;

          oImg = renderer.domElement;

          if (oImg.style.backgroundColor && oAscii.rows.length && oAscii.rows[0].cells.length) {

            oAscii.rows[0].cells[0].style.backgroundColor = oImg.style.backgroundColor;
            oAscii.rows[0].cells[0].style.color = oImg.style.color;

          }

          oAscii.cellSpacing = 0;
          oAscii.cellPadding = 0;

          const oStyle = oAscii.style;
          oStyle.whiteSpace = 'pre';
          oStyle.margin = '0px';
          oStyle.padding = '0px';
          oStyle.letterSpacing = fLetterSpacing + 'px';
          oStyle.fontFamily = strFont;
          oStyle.fontSize = fFontSize + 'px';
          oStyle.lineHeight = fLineHeight + 'px';
          oStyle.textAlign = 'left';
          oStyle.textDecoration = 'none';

          asciiWidthCells = iWidth;
          asciiHeightCells = Math.max(1, Math.ceil(iHeight / 2));
          asciiCellCount = asciiWidthCells * asciiHeightCells;
          stageThresholds = new Uint8Array(asciiCellCount * STAGE_COUNT);
          for (let idx = 0; idx < asciiCellCount; idx++) {
            for (let stage = 0; stage < STAGE_COUNT; stage++) {
              const seed = idx * (STAGE_COUNT + 1) + stage + 1;
              const r = hash01(seed);
              stageThresholds[idx * STAGE_COUNT + stage] = Math.min(STAGE_STEPS - 1, Math.floor(r * STAGE_STEPS));
            }
          }

        }
        const aDefaultCharList = (' .,:;i1tfLCG08@').split('');
        const aDefaultColorCharList = (' CGO08@').split('');
        const strFont = 'courier new, monospace';

        const oCanvasImg = renderer.domElement;

        const oCanvas = document.createElement('canvas');
        if (!oCanvas.getContext) {

          return;

        }

        const oCtx = oCanvas.getContext('2d');
        if (!oCtx.getImageData) {

          return;

        }

        let aCharList = (bColor ? aDefaultColorCharList : aDefaultCharList);

        if (charSet) aCharList = charSet;

        const fFontSize = (2 / fResolution) * iScale;
        const fLineHeight = (2 / fResolution) * iScale;

        let fLetterSpacing = 0;

        if (strResolution === 'low') {

          switch (iScale) {

            case 1: fLetterSpacing = -1; break;
            case 2:
            case 3: fLetterSpacing = -2.1; break;
            case 4: fLetterSpacing = -3.1; break;
            case 5: fLetterSpacing = -4.15; break;

          }

        }

        if (strResolution === 'medium') {

          switch (iScale) {

            case 1: fLetterSpacing = 0; break;
            case 2: fLetterSpacing = -1; break;
            case 3: fLetterSpacing = -1.04; break;
            case 4:
            case 5: fLetterSpacing = -2.1; break;

          }

        }

        if (strResolution === 'high') {

          switch (iScale) {

            case 1:
            case 2: fLetterSpacing = 0; break;
            case 3:
            case 4:
            case 5: fLetterSpacing = -1; break;

          }

        }


        this.setCharSet = function (chars) {

          if (!chars || !chars.length) return;
          aCharList = Array.isArray(chars) ? chars.join('') : String(chars);

        };


        function asciifyImage(oAscii) {

          if (iWidth <= 0 || iHeight <= 0) return;
          oCtx.clearRect(0, 0, iWidth, iHeight);
          oCtx.drawImage(oCanvasImg, 0, 0, iWidth, iHeight);
          const oImgData = oCtx.getImageData(0, 0, iWidth, iHeight).data;

          let strChars = '';
          let paletteIndex = 0;

          const effectiveStages = Math.min(STAGE_COUNT, Math.max(0, aCharList.length - 1));
          const stageStepCounts = new Array(STAGE_COUNT).fill(0);
          const hasThresholds = transitionProgress > 0 && stageThresholds && stageThresholds.length === asciiCellCount * STAGE_COUNT && effectiveStages > 0;
          if (hasThresholds) {
            for (let stage = 0; stage < STAGE_COUNT; stage++) {
              const stageStart = stage / STAGE_COUNT;
              const stageEnd = (stage + 1) / STAGE_COUNT;
              let p = (transitionProgress - stageStart) / (stageEnd - stageStart);
              if (p <= 0) {
                stageStepCounts[stage] = 0;
              } else if (p >= 1) {
                stageStepCounts[stage] = STAGE_STEPS;
              } else {
                stageStepCounts[stage] = Math.min(STAGE_STEPS, Math.floor(p * STAGE_STEPS));
              }
            }
          }

          for (let y = 0; y < iHeight; y += 2) {

            for (let x = 0; x < iWidth; x++) {

              const iOffset = (y * iWidth + x) * 4;

              const iRed = oImgData[iOffset];
              const iGreen = oImgData[iOffset + 1];
              const iBlue = oImgData[iOffset + 2];
              const iAlpha = oImgData[iOffset + 3];

              let fBrightness = (0.3 * iRed + 0.59 * iGreen + 0.11 * iBlue) / 255;

              if (iAlpha === 0) {

                fBrightness = 1;

              }

              const lastCharIndex = aCharList.length - 1;
              let iCharIdx = Math.floor((1 - fBrightness) * lastCharIndex);

              if (bInvert) {

                iCharIdx = lastCharIndex - iCharIdx;

              }

              let finalIndex = iCharIdx;

              let appliedStage = -1;
              const isForeground = iCharIdx < lastCharIndex;

              if (hasThresholds && isForeground) {
                const asciiRow = Math.floor(y / 2);
                const cellIndex = asciiRow * asciiWidthCells + x;
                if (cellIndex < asciiCellCount) {
                  for (let stage = 0; stage < effectiveStages; stage++) {
                    const stepCount = stageStepCounts[stage];
                    if (stepCount <= 0) continue;
                    const threshold = stageThresholds[cellIndex * STAGE_COUNT + stage];
                    const targetIndex = stage + 1;
                    if (stepCount > threshold && finalIndex < targetIndex && finalIndex >= stage) {
                      finalIndex = targetIndex;
                      appliedStage = Math.max(appliedStage, stage);
                    }
                  }
                }
              }

              if (transitionProgress >= 1 && isForeground) {
                appliedStage = Math.max(appliedStage, STAGE_COUNT - 1);
                finalIndex = Math.max(finalIndex, Math.min(STAGE_COUNT, lastCharIndex));
              }

              if (finalIndex < 0) finalIndex = 0;
              if (finalIndex >= aCharList.length) finalIndex = lastCharIndex;

              let strThisChar = aCharList[finalIndex];

              if (appliedStage >= 0 && isForeground) {
                const replacement = stageReplacementChars[appliedStage];
                if (replacement !== undefined) {
                  strThisChar = replacement;
                }
              }

              if (strThisChar === undefined || strThisChar === ' ') {
                strThisChar = '&nbsp;';
              }

              if (bColor) {

                const styles = [`color:rgb(${iRed},${iGreen},${iBlue});`];
                if (bBlock) styles.push(`background-color:rgb(${iRed},${iGreen},${iBlue});`);
                if (bAlpha) styles.push(`opacity:${iAlpha / 255};`);
                strChars += `<span style="${styles.join('')}">${strThisChar}</span>`;

              } else {

                const color = palette[paletteIndex % palette.length];
                paletteIndex++;
                strChars += `<span style="color:${color};">${strThisChar}</span>`;

              }

            }

            strChars += '<br/>';

          }

          oAscii.innerHTML = `<tr><td style="display:block;width:${width}px;height:${height}px;overflow:hidden">${strChars}</td></tr>`;

        }

      }

    }

    const globalPointer = { active: false, nx: 0, ny: 0 };
    function updateGlobalPointer(e) {
      const w = innerWidth || 1;
      const h = innerHeight || 1;
      globalPointer.active = true;
      globalPointer.nx = THREE.MathUtils.clamp((e.clientX / w) * 2 - 1, -1, 1);
      globalPointer.ny = THREE.MathUtils.clamp((e.clientY / h) * 2 - 1, -1, 1);
    }
    function resetGlobalPointer() {
      globalPointer.active = false;
      globalPointer.nx = 0;
      globalPointer.ny = 0;
    }
    window.addEventListener('pointermove', updateGlobalPointer, { passive: true });
    window.addEventListener('pointerleave', resetGlobalPointer, { passive: true });
    window.addEventListener('pointerout', (e) => {
      if (!e.relatedTarget) resetGlobalPointer();
    }, { passive: true });
    window.addEventListener('blur', resetGlobalPointer);

    const NUMBER_BASE_ROT_X = -0.12;
    const NUMBER_BASE_ROT_Y = 0.55;
    const NUMBER_AUTO_ROT_SPEED = 0.42;
    const NUMBER_ROT_MAX_X = Math.PI * 0.35;
    const NUMBER_ROT_MAX_Y = Math.PI * 0.55;

    const loadRapier = (() => {
      let modulePromise = null;
      let initPromise = null;
      return () => {
        if (!modulePromise) {
          modulePromise = import('https://unpkg.com/@dimforge/rapier3d-compat@0.13.1/rapier.es.js').then((mod) => {
            const rapier = mod?.default ?? mod;
            if (!rapier) throw new Error('Failed to load Rapier');
            return rapier;
          });
        }
        if (!initPromise) {
          initPromise = modulePromise.then(async (rapier) => {
            if (typeof rapier.init === 'function') {
              await rapier.init();
            }
            return rapier;
          });
        }
        return initPromise;
      };
    })();

    const getHelvetikerRegular = (() => {
      let promise = null;
      return () => {
        if (!promise) {
          const loader = new FontLoader();
          promise = new Promise((resolve, reject) => {
            loader.load(
              'https://unpkg.com/three@0.168.0/examples/fonts/helvetiker_regular.typeface.json',
              resolve,
              undefined,
              reject
            );
          });
        }
        return promise;
      };
    })();

    // ===== effect factories =====
    function createTorus(cellEl) {
      if (!cellEl) return null;

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.NoToneMapping;
      renderer.setClearColor(0xdeefff, 0);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.domElement.style.width = '100%';
      renderer.domElement.style.height = '100%';
      renderer.domElement.style.display = 'block';
      renderer.domElement.style.touchAction = 'none';
      cellEl.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xdeefff);
      const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
      camera.position.set(0, 0, 4);

      scene.add(new THREE.AmbientLight(0x445566, 1));
      const d = new THREE.DirectionalLight(0xffffff, 1.2);
      d.position.set(1, 2, 3);
      scene.add(d);

      const mesh = new THREE.Mesh(
        new THREE.TorusKnotGeometry(1, 0.35, 160, 24),
        new THREE.MeshStandardMaterial({ metalness: 0.7, roughness: 0.2, color: 0x7b9cff })
      );
      scene.add(mesh);

      let disposed = false;

      return {
        resize(width, height) {
          const w = Math.max(1, Math.floor(width));
          const h = Math.max(1, Math.floor(height));
          renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
          renderer.setSize(w, h, false);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
        },
        tick(time) {
          if (disposed) return;
          mesh.rotation.x = time * 0.6;
          mesh.rotation.y = time * 0.8;
          renderer.render(scene, camera);
        },
        dispose() {
          if (disposed) return;
          disposed = true;
          mesh.geometry.dispose();
          mesh.material.dispose();
          renderer.dispose();
          if (renderer.domElement.parentNode) {
            renderer.domElement.parentNode.removeChild(renderer.domElement);
          }
        }
      };
    }

    // === ★ Ascii対応のNumber3（セル内独立レンダラー＋AsciiEffect）
    function createNumber3(cellEl) {
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
      camera.position.set(0, 0, 2.2);

      scene.add(new THREE.AmbientLight(0x334455, 1.0));
      const d = new THREE.DirectionalLight(0xffffff, 1.0);
      d.position.set(2, 2, 3);
      scene.add(d);

      const group = new THREE.Group();
      scene.add(group);
      group.rotation.set(NUMBER_BASE_ROT_X, NUMBER_BASE_ROT_Y, 0);

      const loader = new FontLoader();
      loader.load(
        'https://unpkg.com/three@0.168.0/examples/fonts/helvetiker_bold.typeface.json',
        (font) => {
          const geo = new TextGeometry('3', {
            font,
            size: 1.4,
            depth: 0.4,
            curveSegments: 8,
            bevelEnabled: true,
            bevelThickness: 0.03,
            bevelSize: 0.02,
            bevelSegments: 2,
          });
          geo.center();
          const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
          const mesh = new THREE.Mesh(geo, mat);
          group.add(mesh);
        }
      );

      const localRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      localRenderer.outputColorSpace = THREE.SRGBColorSpace;
      localRenderer.toneMapping = THREE.NoToneMapping;
      localRenderer.setClearColor(0x000000, 1);
      localRenderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));

      const normalChars = '321 ';
      const ZOOM_IDLE_Z = 2.2;
      const ZOOM_ACTIVE_Z = 0.6;
      const ZOOM_DURATION = 0.5;
      const ASCII_TRANSITION_DURATION = 1.0;

      const hoverState = {
        progress: 0,
        pendingTarget: 0,
        currentTarget: 0,
        startProgress: 0,
        transitionStart: null,
        transitionQueued: false
      };

      const asciiPalette = ['#024b9e', '#217adf', '#72b4ff'];

      const effect = new AsciiEffect(localRenderer, normalChars, {
        invert: false,
        colorPalette: asciiPalette,
        stageReplacementChars: ['2', '1', '0']
      });

      let asciiProgress = 0;
      let lastAsciiUpdateTime = null;
      let width = 1;
      let height = 1;
      let disposed = false;
      let eventsBound = false;

      const pointerWithinCell = () => {
        if (!cellEl || !globalPointer.active) return false;
        const rect = cellEl.getBoundingClientRect();
        const w = window.innerWidth || 1;
        const h = window.innerHeight || 1;
        const clientX = ((globalPointer.nx + 1) * 0.5) * w;
        const clientY = ((globalPointer.ny + 1) * 0.5) * h;
        return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
      };

      const applyEffectStyles = (dom) => {
        if (!dom) return;
        dom.style.position = 'absolute';
        dom.style.inset = '0';
        dom.style.width = '100%';
        dom.style.height = '100%';
        dom.style.backgroundColor = '#deefff';
        dom.style.color = asciiPalette[0];
        dom.style.userSelect = 'none';
        dom.style.touchAction = 'none';
        dom.style.cursor = 'default';
        dom.style.pointerEvents = 'auto';
      };

      const queueHoverTransition = (target) => {
        if (hoverState.pendingTarget !== target) {
          hoverState.pendingTarget = target;
          hoverState.transitionQueued = true;
        } else if (!hoverState.transitionQueued && hoverState.currentTarget !== target) {
          hoverState.transitionQueued = true;
        }
      };

      const handleEnter = () => { queueHoverTransition(1); };
      const handleLeave = () => { queueHoverTransition(0); };
      const handleWindowPointerOut = (e) => { if (!e.relatedTarget) handleLeave(); };
      const handleWindowBlur = () => { handleLeave(); };

      const bindCellEvents = () => {
        if (!cellEl || eventsBound) return;
        if (!cellEl.style.position) cellEl.style.position = 'relative';
        cellEl.addEventListener('pointerenter', handleEnter);
        cellEl.addEventListener('pointerleave', handleLeave);
        cellEl.addEventListener('pointercancel', handleLeave);
        cellEl.addEventListener('mouseenter', handleEnter);
        cellEl.addEventListener('mouseleave', handleLeave);
        window.addEventListener('pointerout', handleWindowPointerOut, { passive: true });
        window.addEventListener('blur', handleWindowBlur);
        eventsBound = true;
      };

      const unbindCellEvents = () => {
        if (!cellEl || !eventsBound) return;
        cellEl.removeEventListener('pointerenter', handleEnter);
        cellEl.removeEventListener('pointerleave', handleLeave);
        cellEl.removeEventListener('pointercancel', handleLeave);
        cellEl.removeEventListener('mouseenter', handleEnter);
        cellEl.removeEventListener('mouseleave', handleLeave);
        window.removeEventListener('pointerout', handleWindowPointerOut, { passive: true });
        window.removeEventListener('blur', handleWindowBlur);
        eventsBound = false;
      };

      applyEffectStyles(effect.domElement);
      effect.domElement.classList.add('ascii-effect');
      effect.domElement.addEventListener('pointerenter', handleEnter);
      effect.domElement.addEventListener('pointerleave', handleLeave);
      effect.domElement.addEventListener('pointercancel', handleLeave);
      effect.domElement.addEventListener('mouseenter', handleEnter);
      effect.domElement.addEventListener('mouseleave', handleLeave);

      if (cellEl) {
        bindCellEvents();
        cellEl.appendChild(effect.domElement);
      }

      const pointerRot = { currentX: 0, currentY: 0 };

      function update(t = 0) {
        const inside = pointerWithinCell();
        if (inside) {
          queueHoverTransition(1);
        } else {
          queueHoverTransition(0);
        }

        if (hoverState.transitionQueued) {
          hoverState.transitionQueued = false;
          if (hoverState.currentTarget !== hoverState.pendingTarget) {
            hoverState.startProgress = hoverState.progress;
            hoverState.currentTarget = hoverState.pendingTarget;
            hoverState.transitionStart = t;
          }
        }

        if (hoverState.transitionStart !== null) {
          const elapsed = Math.max(0, t - hoverState.transitionStart);
          const raw = ZOOM_DURATION <= 0 ? 1 : Math.min(1, elapsed / ZOOM_DURATION);
          const eased = raw < 0.5 ? 2 * raw * raw : 1 - Math.pow(-2 * raw + 2, 2) / 2;
          hoverState.progress = THREE.MathUtils.lerp(hoverState.startProgress, hoverState.currentTarget, eased);
          if (raw >= 1) {
            hoverState.progress = hoverState.currentTarget;
            hoverState.startProgress = hoverState.progress;
            hoverState.transitionStart = null;
          }
        } else {
          hoverState.progress = hoverState.currentTarget;
        }

        const progress = THREE.MathUtils.clamp(hoverState.progress, 0, 1);

        const dt = lastAsciiUpdateTime === null ? 0 : Math.max(0, Math.min(0.2, t - lastAsciiUpdateTime));
        lastAsciiUpdateTime = t;

        const asciiTarget = hoverState.currentTarget;
        if (asciiProgress !== asciiTarget) {
          const direction = asciiTarget > asciiProgress ? 1 : -1;
          asciiProgress += direction * (dt / ASCII_TRANSITION_DURATION);
          if ((direction > 0 && asciiProgress > asciiTarget) || (direction < 0 && asciiProgress < asciiTarget)) {
            asciiProgress = asciiTarget;
          }
        }
        asciiProgress = THREE.MathUtils.clamp(asciiProgress, 0, 1);

        effect.setTransitionProgress(asciiProgress);

        const zoomZ = THREE.MathUtils.lerp(ZOOM_IDLE_Z, ZOOM_ACTIVE_Z, progress);
        camera.position.z = zoomZ;
        const active = globalPointer.active;
        const targetY = active ? THREE.MathUtils.clamp(globalPointer.nx * NUMBER_ROT_MAX_Y, -NUMBER_ROT_MAX_Y, NUMBER_ROT_MAX_Y) : 0;
        const targetX = active ? THREE.MathUtils.clamp(-globalPointer.ny * NUMBER_ROT_MAX_X, -NUMBER_ROT_MAX_X, NUMBER_ROT_MAX_X) : 0;
        const ease = active ? 0.18 : 0.12;
        pointerRot.currentX += (targetX - pointerRot.currentX) * ease;
        pointerRot.currentY += (targetY - pointerRot.currentY) * ease;
        const baseY = NUMBER_BASE_ROT_Y + t * NUMBER_AUTO_ROT_SPEED;
        group.rotation.y = baseY + pointerRot.currentY;
        group.rotation.x = NUMBER_BASE_ROT_X + pointerRot.currentX;
      }

      return {
        resize(newWidth, newHeight) {
          width = Math.max(1, Math.floor(newWidth));
          height = Math.max(1, Math.floor(newHeight));
          localRenderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
          localRenderer.setSize(width, height, false);
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          effect.setSize(width, height);
        },
        tick(time) {
          if (disposed) return;
          update(time);
          effect.render(scene, camera);
        },
        dispose() {
          if (disposed) return;
          disposed = true;
          unbindCellEvents();
          effect.domElement.removeEventListener('pointerenter', handleEnter);
          effect.domElement.removeEventListener('pointerleave', handleLeave);
          effect.domElement.removeEventListener('pointercancel', handleLeave);
          effect.domElement.removeEventListener('mouseenter', handleEnter);
          effect.domElement.removeEventListener('mouseleave', handleLeave);
          if (effect.domElement.parentNode) {
            effect.domElement.parentNode.removeChild(effect.domElement);
          }
          localRenderer.dispose();
        }
      };
    }



    function createParticles(cellEl) {
      if (!cellEl) return null;

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.NoToneMapping;
      renderer.setClearColor(0xdeefff, 0);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.domElement.style.width = '100%';
      renderer.domElement.style.height = '100%';
      renderer.domElement.style.display = 'block';
      renderer.domElement.style.touchAction = 'none';
      cellEl.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xdeefff);
      const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
      camera.position.set(0, 0, 3.2);

      const N = 1800;
      const positions = new Float32Array(N * 3);
      for (let i = 0; i < N; i++) {
        const r = 1.2 + Math.random() * 0.9;
        const th = Math.random() * Math.PI * 2;
        const ph = Math.acos(2 * Math.random() - 1);
        positions[i * 3] = r * Math.sin(ph) * Math.cos(th);
        positions[i * 3 + 1] = r * Math.sin(ph) * Math.sin(th);
        positions[i * 3 + 2] = r * Math.cos(ph);
      }
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const mat = new THREE.PointsMaterial({ size: 0.02, transparent: true, opacity: 0.9, color: 0x024b9e });
      const pts = new THREE.Points(geo, mat);
      scene.add(pts);

      let disposed = false;

      return {
        resize(width, height) {
          const w = Math.max(1, Math.floor(width));
          const h = Math.max(1, Math.floor(height));
          renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
          renderer.setSize(w, h, false);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
        },
        tick(time) {
          if (disposed) return;
          pts.rotation.y = time * 0.35;
          pts.rotation.x = Math.sin(time * 0.5) * 0.25;
          renderer.render(scene, camera);
        },
        dispose() {
          if (disposed) return;
          disposed = true;
          geo.dispose();
          mat.dispose();
          renderer.dispose();
          if (renderer.domElement.parentNode) renderer.domElement.parentNode.removeChild(renderer.domElement);
        }
      };
    }
    function createWaves(cellEl) {
      if (!cellEl) return null;

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.NoToneMapping;
      renderer.setClearColor(0xdeefff, 0);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.domElement.style.width = '100%';
      renderer.domElement.style.height = '100%';
      renderer.domElement.style.display = 'block';
      renderer.domElement.style.touchAction = 'none';
      cellEl.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xdeefff);
      const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
      camera.position.set(0, 0.15, 3.2);

      const COUNT = 220;
      const geo = new THREE.BufferGeometry();
      const positions = new Float32Array(COUNT * 3);
      geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const material = new THREE.LineBasicMaterial({ color: 0x024b9e });
      const line = new THREE.Line(geo, material);
      scene.add(line);

      const updateWave = (t) => {
        const p = geo.attributes.position.array;
        for (let i = 0; i < COUNT; i++) {
          const x = (i / (COUNT - 1)) * 4 - 2;
          p[i * 3] = x;
          p[i * 3 + 1] = Math.sin(x * 2 + t * 2) * 0.4;
          p[i * 3 + 2] = 0;
        }
        geo.attributes.position.needsUpdate = true;
      };

      let disposed = false;

      return {
        resize(width, height) {
          const w = Math.max(1, Math.floor(width));
          const h = Math.max(1, Math.floor(height));
          renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
          renderer.setSize(w, h, false);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
        },
        tick(time) {
          if (disposed) return;
          updateWave(time);
          renderer.render(scene, camera);
        },
        dispose() {
          if (disposed) return;
          disposed = true;
          material.dispose();
          geo.dispose();
          renderer.dispose();
          if (renderer.domElement.parentNode) {
            renderer.domElement.parentNode.removeChild(renderer.domElement);
          }
        }
      };
    }
    // function createBoxes() {
    //   const scene = new THREE.Scene(); const camera = new THREE.PerspectiveCamera(50, 1, .1, 100); camera.position.set(0, 0, 5);
    //   scene.add(new THREE.AmbientLight(0x223344, 1)); const d = new THREE.DirectionalLight(0xffffff, 1); d.position.set(2, 2, 3); scene.add(d);
    //   const grid = 12, count = grid * grid, inst = new THREE.InstancedMesh(new THREE.BoxGeometry(.25, .25, .25), new THREE.MeshStandardMaterial({ color: 0x9cc4ff, metalness: .5, roughness: .35 }), count);
    //   let i = 0, m = new THREE.Matrix4(); for (let x = 0; x < grid; x++) for (let y = 0; y < grid; y++) {
    //     m.setPosition((x - grid / 2) * .35, (y - grid / 2) * .35, 0); inst.setMatrixAt(i++, m);
    //   }
    //   scene.add(inst); return { scene, camera, update(t) { inst.rotation.x = t * .5; inst.rotation.y = t * .6; } };
    // }
    function createSphereWire(cellEl) {
      if (!cellEl) return null;

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.NoToneMapping;
      renderer.setClearColor(0xdeefff, 0);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.domElement.style.width = '100%';
      renderer.domElement.style.height = '100%';
      renderer.domElement.style.display = 'block';
      renderer.domElement.style.touchAction = 'none';
      cellEl.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xdeefff);
      const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
      camera.position.set(0, 0, 3.6);

      const geometry = new THREE.WireframeGeometry(new THREE.IcosahedronGeometry(1.2, 2));
      const material = new THREE.LineBasicMaterial({ color: 0x024b9e });
      const line = new THREE.LineSegments(geometry, material);
      scene.add(line);

      let disposed = false;

      return {
        resize(width, height) {
          const w = Math.max(1, Math.floor(width));
          const h = Math.max(1, Math.floor(height));
          renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
          renderer.setSize(w, h, false);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
        },
        tick(time) {
          if (disposed) return;
          line.rotation.y = time * 0.6;
          line.rotation.x = Math.sin(time * 0.8) * 0.2;
          renderer.render(scene, camera);
        },
        dispose() {
          if (disposed) return;
          disposed = true;
          geometry.dispose();
          material.dispose();
          renderer.dispose();
          if (renderer.domElement.parentNode) renderer.domElement.parentNode.removeChild(renderer.domElement);
        }
      };
    }

    function createNumber2(cellEl) {
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
      camera.position.set(0, 0, 2.2);

      scene.add(new THREE.AmbientLight(0x334455, 1.0));
      const d = new THREE.DirectionalLight(0xffffff, 1.3);
      d.position.set(2, 2, 3);
      scene.add(d);

      const group = new THREE.Group();
      scene.add(group);
      group.rotation.set(NUMBER_BASE_ROT_X, NUMBER_BASE_ROT_Y, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.NoToneMapping;
      renderer.setClearColor(0xdeefff, 0);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));

      const canvasEl = renderer.domElement;
      canvasEl.style.width = '100%';
      canvasEl.style.height = '100%';
      canvasEl.style.display = 'block';
      canvasEl.style.touchAction = 'none';

      if (cellEl) {
        cellEl.appendChild(canvasEl);
        cellEl.style.userSelect = 'none';
        cellEl.style.touchAction = 'none';
        cellEl.style.cursor = 'default';
      }

      const COUNT = 2000;
      let targetPoints = null;
      let scatter = false;
      let disposed = false;

      const pg = new THREE.BufferGeometry();
      const positions = new Float32Array(COUNT * 3);
      const velocities = new Float32Array(COUNT * 3);
      const colors = new Float32Array(COUNT * 3);
      const palette = ['#024b9e', '#217adf', '#72b4ff'].map((hex) => new THREE.Color(hex));

      for (let i = 0; i < COUNT; i++) {
        const r = Math.cbrt(Math.random()) * 0.8;
        const th = Math.random() * Math.PI * 2;
        const ph = Math.acos(2 * Math.random() - 1);
        const x = r * Math.sin(ph) * Math.cos(th);
        const y = r * Math.sin(ph) * Math.sin(th);
        const z = r * Math.cos(ph);
        const idx = i * 3;
        positions[idx] = x;
        positions[idx + 1] = y;
        positions[idx + 2] = z;
        velocities[idx] = velocities[idx + 1] = velocities[idx + 2] = 0;
        palette[Math.floor(Math.random() * palette.length)].toArray(colors, idx);
      }

      pg.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      pg.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const pm = new THREE.PointsMaterial({ size: 0.05, sizeAttenuation: true, vertexColors: true });
      const points = new THREE.Points(pg, pm);
      group.add(points);

      const loader = new FontLoader();
      loader.load(
        'https://unpkg.com/three@0.168.0/examples/fonts/helvetiker_bold.typeface.json',
        (font) => {
          const geo = new TextGeometry('2', {
            font,
            size: 1.4,
            depth: 0.4,
            curveSegments: 8,
            bevelEnabled: true,
            bevelThickness: 0.03,
            bevelSize: 0.02,
            bevelSegments: 2,
          });
          geo.center();
          geo.computeVertexNormals();
          targetPoints = samplePointsOnGeometrySurface(geo, COUNT);
          const mat = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            metalness: 0.75,
            roughness: 0.25,
            visible: false
          });
          const mesh = new THREE.Mesh(geo, mat);
          group.add(mesh);
        }
      );

      const handlePointerEnter = () => { scatter = true; };
      const handlePointerLeave = () => { scatter = false; };

      if (cellEl) {
        cellEl.addEventListener('pointerenter', handlePointerEnter);
        cellEl.addEventListener('pointerleave', handlePointerLeave);
        cellEl.addEventListener('pointercancel', handlePointerLeave);
      }

      const pointerRot = { currentX: 0, currentY: 0 };

      function update(t) {
        const active = globalPointer.active;
        const targetY = active ? THREE.MathUtils.clamp(globalPointer.nx * NUMBER_ROT_MAX_Y, -NUMBER_ROT_MAX_Y, NUMBER_ROT_MAX_Y) : 0;
        const targetX = active ? THREE.MathUtils.clamp(-globalPointer.ny * NUMBER_ROT_MAX_X, -NUMBER_ROT_MAX_X, NUMBER_ROT_MAX_X) : 0;
        const ease = active ? 0.16 : 0.1;
        pointerRot.currentX += (targetX - pointerRot.currentX) * ease;
        pointerRot.currentY += (targetY - pointerRot.currentY) * ease;
        const baseY = NUMBER_BASE_ROT_Y + t * NUMBER_AUTO_ROT_SPEED;
        group.rotation.y = baseY + pointerRot.currentY;
        group.rotation.x = NUMBER_BASE_ROT_X + pointerRot.currentX;

        const pos = pg.attributes.position.array;
        if (!targetPoints) return;

        const dt = 0.016;
        const gatherStrength = 6.0;
        const damping = 0.88;
        const scatterImpulse = 1.5;
        const maxSpeed = 2.0;

        for (let i = 0; i < COUNT; i++) {
          const idx = i * 3;
          const tx = targetPoints[idx];
          const ty = targetPoints[idx + 1];
          const tz = targetPoints[idx + 2];

          let x = pos[idx];
          let y = pos[idx + 1];
          let z = pos[idx + 2];
          let vx = velocities[idx];
          let vy = velocities[idx + 1];
          let vz = velocities[idx + 2];

          if (scatter) {
            vx += (Math.random() - 0.5) * scatterImpulse;
            vy += (Math.random() - 0.5) * scatterImpulse;
            vz += (Math.random() - 0.5) * scatterImpulse;
            vx += (x - tx) * 0.2;
            vy += (y - ty) * 0.2;
            vz += (z - tz) * 0.2;
          } else {
            vx += (tx - x) * gatherStrength * dt;
            vy += (ty - y) * gatherStrength * dt;
            vz += (tz - z) * gatherStrength * dt;
          }

          vx *= damping;
          vy *= damping;
          vz *= damping;
          const speedSq = vx * vx + vy * vy + vz * vz;
          if (speedSq > maxSpeed * maxSpeed) {
            const scale = maxSpeed / Math.sqrt(speedSq);
            vx *= scale;
            vy *= scale;
            vz *= scale;
          }

          x += vx * dt;
          y += vy * dt;
          z += vz * dt;

          velocities[idx] = vx;
          velocities[idx + 1] = vy;
          velocities[idx + 2] = vz;
          pos[idx] = x;
          pos[idx + 1] = y;
          pos[idx + 2] = z;
        }

        pg.attributes.position.needsUpdate = true;
      }

      return {
        resize(width, height) {
          const w = Math.max(1, Math.floor(width));
          const h = Math.max(1, Math.floor(height));
          renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
          renderer.setSize(w, h, false);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
        },
        tick(time) {
          if (disposed) return;
          update(time);
          renderer.render(scene, camera);
        },
        dispose() {
          if (disposed) return;
          disposed = true;
          if (cellEl) {
            cellEl.removeEventListener('pointerenter', handlePointerEnter);
            cellEl.removeEventListener('pointerleave', handlePointerLeave);
            cellEl.removeEventListener('pointercancel', handlePointerLeave);
          }
          if (canvasEl.parentNode) {
            canvasEl.parentNode.removeChild(canvasEl);
          }
          renderer.dispose();
        }
      };

      // ---- ヘルパー：ジオメトリ表面から一様サンプリング（indexed/non-indexed両対応）----
      function samplePointsOnGeometrySurface(geometry, count) {
        const posAttr = geometry.getAttribute('position');
        const indexAttr = geometry.getIndex();

        const getTriangle = (triIndex, outA, outB, outC) => {
          if (indexAttr) {
            const i0 = indexAttr.getX(triIndex * 3);
            const i1 = indexAttr.getX(triIndex * 3 + 1);
            const i2 = indexAttr.getX(triIndex * 3 + 2);
            outA.fromBufferAttribute(posAttr, i0);
            outB.fromBufferAttribute(posAttr, i1);
            outC.fromBufferAttribute(posAttr, i2);
          } else {
            const i0 = triIndex * 3;
            const i1 = i0 + 1;
            const i2 = i0 + 2;
            outA.fromBufferAttribute(posAttr, i0);
            outB.fromBufferAttribute(posAttr, i1);
            outC.fromBufferAttribute(posAttr, i2);
          }
        };

        const triCount = indexAttr ? (indexAttr.count / 3) : (posAttr.count / 3);

        const areas = new Float32Array(triCount);
        let totalArea = 0;
        const a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
        const ab = new THREE.Vector3(), ac = new THREE.Vector3();

        for (let i = 0; i < triCount; i++) {
          getTriangle(i, a, b, c);
          ab.copy(b).sub(a);
          ac.copy(c).sub(a);
          const area = ab.cross(ac).length() * 0.5;
          totalArea += area;
          areas[i] = totalArea;
        }
        if (totalArea === 0) {
          console.warn('samplePointsOnGeometrySurface: totalArea = 0（頂点/面の取得に失敗）');
          return new Float32Array(count * 3).fill(0);
        }

        const out = new Float32Array(count * 3);
        const p = new THREE.Vector3();
        const tmp = new THREE.Vector3();

        const pickTriangle = () => {
          const r = Math.random() * totalArea;
          let lo = 0, hi = triCount - 1;
          while (lo < hi) {
            const mid = (lo + hi) >>> 1;
            if (r <= areas[mid]) hi = mid; else lo = mid + 1;
          }
          return lo;
        };

        for (let i = 0; i < count; i++) {
          const ti = pickTriangle();
          getTriangle(ti, a, b, c);

          let u = Math.random();
          let v = Math.random();
          if (u + v > 1) { u = 1 - u; v = 1 - v; }

          p.copy(a);
          tmp.copy(b).sub(a); p.addScaledVector(tmp, u);
          tmp.copy(c).sub(a); p.addScaledVector(tmp, v);

          out[i * 3] = p.x;
          out[i * 3 + 1] = p.y;
          out[i * 3 + 2] = p.z;
        }
        return out;
      }

    }


    function createGlassTextEffect(cellEl, options = {}) {
      if (!cellEl) return null;

      const {
        text = '1',
        textOptions = {},
        fontUrl = 'https://unpkg.com/three@0.168.0/examples/fonts/helvetiker_regular.typeface.json',
        halftone = false,
        autoRotateSpeed = NUMBER_AUTO_ROT_SPEED,
        useGlobalPointer = true,
        hoverZoom = true,
        pointerMode = 'global',
        rootClasses = [],
        canvasClasses = [],
        groupYOffset = 0.35,
        baseRotationX = NUMBER_BASE_ROT_X,
        baseRotationY = NUMBER_BASE_ROT_Y,
        groupScale = 1,
        refSceneSetup = null
      } = options;

      const styleId = 'glass-text-effect-style';
      if (!document.getElementById(styleId)) {
        const styleEl = document.createElement('style');
        styleEl.id = styleId;
        styleEl.textContent = `
.glass-text-effect, .scene3-halftone { position: absolute; inset: 0; color: #fff; font: 14px/1.4 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Noto Sans JP,Helvetica,Arial; pointer-events: none; }
.glass-text-effect_canvas, .scene3-halftone_canvas { position: absolute; inset: 0; pointer-events: auto; }
        `;
        document.head.appendChild(styleEl);
      }

      if (!cellEl.style.position) cellEl.style.position = 'relative';

      const root = document.createElement('div');
      root.classList.add('glass-text-effect');
      rootClasses.forEach((cls) => root.classList.add(cls));
      cellEl.appendChild(root);

      const canvasLayer = document.createElement('div');
      canvasLayer.classList.add('glass-text-effect_canvas');
      canvasClasses.forEach((cls) => canvasLayer.classList.add(cls));
      root.appendChild(canvasLayer);

      const localRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      localRenderer.outputColorSpace = THREE.SRGBColorSpace;
      localRenderer.toneMapping = THREE.ACESFilmicToneMapping;
      localRenderer.toneMappingExposure = 1.1;
      localRenderer.autoClear = false;
      canvasLayer.appendChild(localRenderer.domElement);
      localRenderer.domElement.style.width = '100%';
      localRenderer.domElement.style.height = '100%';
      localRenderer.domElement.style.display = 'block';
      localRenderer.domElement.style.touchAction = 'none';

      const scene = new THREE.Scene();
      const refScene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);

      const controls = new OrbitControls(camera, localRenderer.domElement);
      controls.enableDamping = true;
      controls.minDistance = 1.2;
      controls.maxDistance = 6.0;
      controls.enableRotate = false;
      controls.enablePan = false;
      controls.target.set(0, groupYOffset, 0);
      controls.update();
      localRenderer.domElement.style.cursor = 'default';

      const pointerRot = { currentX: 0, currentY: 0 };
      const ROT_MAX_X = Math.PI * 0.3;
      const ROT_MAX_Y = Math.PI * 0.5;
      const CAMERA_FAR = new THREE.Vector3(0.6, 0.8, 3.2);
      const CAMERA_DEFAULT = CAMERA_FAR.clone().multiplyScalar(0.6);
      const CAMERA_HOVER = CAMERA_FAR.clone().multiplyScalar(0.42);
      const zoomState = hoverZoom ? { current: 0, target: 0 } : null;
      camera.position.copy(CAMERA_DEFAULT);

      if (hoverZoom && zoomState) {
        const handleHoverStart = () => { zoomState.target = 1; };
        const handleHoverEnd = () => { zoomState.target = 0; };
        localRenderer.domElement.addEventListener('pointerenter', handleHoverStart);
        localRenderer.domElement.addEventListener('pointerleave', handleHoverEnd);
        localRenderer.domElement.addEventListener('pointercancel', handleHoverEnd);
        if (cellEl) {
          cellEl.addEventListener('pointerenter', handleHoverStart);
          cellEl.addEventListener('pointerleave', handleHoverEnd);
          cellEl.addEventListener('pointercancel', handleHoverEnd);
        }
      }

      const localPointer = { active: false, nx: 0, ny: 0 };
      if (pointerMode === 'cell') {
        const updateLocalPointer = (e) => {
          const rect = canvasLayer.getBoundingClientRect();
          if (!rect.width || !rect.height) return;
          localPointer.active = true;
          const nx = (e.clientX - rect.left) / rect.width;
          const ny = (e.clientY - rect.top) / rect.height;
          localPointer.nx = THREE.MathUtils.clamp(nx * 2 - 1, -1, 1);
          localPointer.ny = THREE.MathUtils.clamp(ny * 2 - 1, -1, 1);
        };
        const resetLocalPointer = () => {
          localPointer.active = false;
          localPointer.nx = 0;
          localPointer.ny = 0;
        };
        canvasLayer.addEventListener('pointerenter', updateLocalPointer, { passive: true });
        canvasLayer.addEventListener('pointermove', updateLocalPointer, { passive: true });
        canvasLayer.addEventListener('pointerleave', resetLocalPointer);
        canvasLayer.addEventListener('pointercancel', resetLocalPointer);
        canvasLayer.addEventListener('pointerout', (e) => {
          const related = e.relatedTarget;
          if (!related || !canvasLayer.contains(related)) resetLocalPointer();
        });
      }

      const skyVert = `
        varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `;
      const skyFrag = `
        precision highp float;
        varying vec2 vUv;
        void main(){
          vec3 c = vec3(0.870588235, 0.937254902, 1.0); // #deefff
          gl_FragColor = vec4(c, 1.0);
        }
      `;
      const skyMat = new THREE.ShaderMaterial({ vertexShader: skyVert, fragmentShader: skyFrag, side: THREE.BackSide });
      const sky = new THREE.Mesh(new THREE.SphereGeometry(50, 16, 16), skyMat);
      const skyForRef = sky.clone();
      scene.add(sky);
      refScene.add(skyForRef);

      const pmremGenerator = new THREE.PMREMGenerator(localRenderer);
      pmremGenerator.compileEquirectangularShader();
      const envScene = new THREE.Scene();
      envScene.add(sky.clone());
      const envMap = pmremGenerator.fromScene(envScene).texture;
      scene.environment = envMap;
      refScene.environment = envMap;
      pmremGenerator.dispose();

      const posterGeo = new THREE.PlaneGeometry(8, 5);
      const posterMat = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0.0 } },
        vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
        fragmentShader: `precision highp float; varying vec2 vUv; uniform float uTime;
          #define PI 3.141592653589793
          vec3 rainbow(float x){ return 0.5 + 0.5*cos(2.0*PI*(x + vec3(0.0,0.33,0.67))); }
          void main(){
            float a = radians(25.0);
            mat2 R = mat2(cos(a), -sin(a), sin(a), cos(a));
            vec2 p = R * (vUv-0.5);
            float q = p.x * 28.0;
            float band = fract(q);
            float edge = smoothstep(0.48, 0.5, abs(band - 0.5));
            vec3 col = rainbow(q*0.03);
            col *= mix(0.25, 1.0, edge);
            gl_FragColor = vec4(col, 1.0);
          }`,
        depthWrite: false
      });
      const poster = new THREE.Mesh(posterGeo, posterMat);
      poster.position.set(0, 0.0, -4.0);
      refScene.add(poster);

      const ball = new THREE.Mesh(new THREE.SphereGeometry(0.8, 32, 32), new THREE.MeshBasicMaterial({ color: 0x00ffff }));
      ball.position.set(-1.6, 1.5, -3.2);
      refScene.add(ball);

      scene.add(new THREE.AmbientLight(0x1a1a1a, 0.3));
      const dir = new THREE.DirectionalLight(0xffffff, 4.5);
      dir.position.set(10, 10, 10);
      scene.add(dir);

      const glassUniforms = {
        uTransparent: { value: 0.85 },
        winResolution: { value: new THREE.Vector2(1, 1) },
        uRefractPower: { value: 0.16 },
        uFrostAmount: { value: 0.35 },
        uSceneTex: { value: null }
      };

      const glassVert = `
        varying vec2 vUv; varying vec3 vNormal; varying vec3 vViewPos;
        void main(){
          vUv = uv;
          vec3 pos = position;
          vec4 worldPos = modelMatrix * vec4(pos, 1.0);
          vec4 mv = viewMatrix * worldPos;
          gl_Position = projectionMatrix * mv;
          vNormal = normalize(normalMatrix * normal);
          vViewPos = -mv.xyz;
        }
      `;
      const glassFrag = `
        precision highp float;
        uniform float uTransparent; uniform vec2 winResolution; uniform float uRefractPower; uniform float uFrostAmount; uniform sampler2D uSceneTex;
        varying vec3 vNormal; varying vec3 vViewPos;
        float random(vec2 p){ return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453); }
        float classicFresnel(vec3 V, vec3 N, float powr){ float f = abs(dot(V,N)); return pow(1.0 - f, powr); }
        const float TAU = 6.28318530718;
        vec3 spectrum(float x){ return 0.5 + 0.5*cos(TAU * (x + vec3(0.0,0.33,0.67))); }
        const int LOOP = 16;
        void main(){
          vec2 uv = gl_FragCoord.xy / winResolution.xy;
          vec3 N = normalize(vNormal);
          vec3 V = normalize(vViewPos);
          vec2 refractNormal = N.xy * (1.0 - N.z * 0.85);
          vec3 refractCol = vec3(0.0);
          const vec3 dispersion = vec3(0.85, 0.92, 1.0);
          for(int i=0;i<LOOP;i++){
            float noiseIntensity = 0.03;
            float noise = random(uv) * noiseIntensity;
            float slide = float(i)/float(LOOP)*0.1 + noise;
            vec2 rR = uv - refractNormal * (uRefractPower + slide*dispersion.r) * uTransparent;
            vec2 rG = uv - refractNormal * (uRefractPower + slide*dispersion.g) * uTransparent;
            vec2 rB = uv - refractNormal * (uRefractPower + slide*dispersion.b) * uTransparent;
            refractCol.r += texture2D(uSceneTex, rR).r;
            refractCol.g += texture2D(uSceneTex, rG).g;
            refractCol.b += texture2D(uSceneTex, rB).b;
          }
          refractCol /= float(LOOP);
          float shininess = 100.0;
          vec3 L = normalize(vec3(10.0,10.0,10.0));
          vec3 H = normalize(V+L);
          float NdotL = max(dot(N,L),0.0);
          float NdotH = max(dot(N,H),0.0);
          float kDiffuse = NdotL;
          float kSpec = pow(NdotH*NdotH, 100.0);
          float fres = classicFresnel(V,N,8.0);
          float hueSeed = fract(dot(N, vec3(0.27,0.45,0.61)) + dot(V, vec3(0.13,0.27,0.41)));
          vec3 tint = spectrum(hueSeed);
          float spread = max(max(abs(refractCol.r - refractCol.g), abs(refractCol.g - refractCol.b)), abs(refractCol.b - refractCol.r));
          float dispersionMask = smoothstep(0.02, 0.22, spread);
          float tintMix = 0.45 * dispersionMask;
          refractCol = mix(refractCol, refractCol * tint, tintMix);
          float frost = clamp(uFrostAmount + dispersionMask * 0.25, 0.0, 0.85);
          refractCol = mix(refractCol, vec3(1.0), frost);
          float reflectionMask = smoothstep(0.04, 0.8, fres);
          float lightTerm = reflectionMask * (0.28*kSpec + 0.04*kDiffuse + 0.4*fres);
          vec3 highlightTint = mix(vec3(1.0), tint, dispersionMask * 0.45);
          refractCol += highlightTint * lightTerm;
          refractCol = clamp(refractCol, 0.0, 1.2);
          gl_FragColor = vec4(refractCol, 1.0);
        }
      `;
      const glassMatFront = new THREE.ShaderMaterial({ vertexShader: glassVert, fragmentShader: glassFrag, uniforms: glassUniforms, side: THREE.FrontSide });
      const glassMatBack = new THREE.ShaderMaterial({ vertexShader: glassVert, fragmentShader: glassFrag, uniforms: glassUniforms, side: THREE.BackSide });

      const ppScene = new THREE.Scene();
      const ppCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
      const ppUniforms = {
        uScene: { value: null },
        resolution: { value: new THREE.Vector2(1, 1) },
        pixelSize: { value: 10.0 },
        dotSize: { value: 0.32 }
      };
      const ppFrag = `
        precision highp float;
        varying vec2 vUv;
        uniform sampler2D uScene;
        uniform vec2 resolution;
        uniform float pixelSize;
        uniform float dotSize;
        const vec3 BASE_COLOR = vec3(0.007843137, 0.296470588, 0.619607843);       // #024b9e
        const vec3 ACCENT_COLOR = vec3(0.211764706, 0.537254902, 0.890196078);     // #3689e3
        const vec3 BACKGROUND_COLOR = vec3(0.980392157, 0.988235294, 1.0);         // #fafdff
        const float ANGLE_A = 15.0;
        const float ANGLE_B = 45.0;
        const float ANGLE_C = 0.0;
        const float ANGLE_K = 75.0;
        mat2 rot(float d){
          float a = radians(d);
          float c = cos(a);
          float s = sin(a);
          return mat2(c, -s, s, c);
        }
        float halftoneDot(vec2 uvScreen, float angleDeg, float coverage){
          float minRes = min(resolution.x, resolution.y);
          float effectiveDotDensity = (minRes / pixelSize);
          float scale = effectiveDotDensity / minRes;
          vec2 uv = uvScreen * scale;
          uv = rot(angleDeg) * uv;
          vec2 gv = fract(uv) - 0.5;
          float r = dotSize * sqrt(clamp(coverage, 0.0, 1.0));
          float d = length(gv);
          float aa = fwidth(d);
          return 1.0 - smoothstep(r - aa, r + aa, d);
        }
        void main(){
          vec2 normalizedPixelSize = pixelSize / resolution;
          vec2 uvPixel = normalizedPixelSize * floor(vUv / normalizedPixelSize);
          vec3 base = texture2D(uScene, uvPixel).rgb;
          float luminance = dot(base, vec3(0.299, 0.587, 0.114));
          float chA = clamp(base.b - 0.25, 0.0, 1.0);
          float chB = clamp(base.g - 0.25, 0.0, 1.0);
          float chC = clamp(base.r - 0.25, 0.0, 1.0);
          float chK = clamp(1.0 - luminance, 0.0, 1.0);
          vec2 uvScreen = vUv * resolution;
          float dotA = halftoneDot(uvScreen, ANGLE_A, chA);
          float dotB = halftoneDot(uvScreen, ANGLE_B, chB);
          float dotC = halftoneDot(uvScreen, ANGLE_C, chC);
          float dotK = halftoneDot(uvScreen, ANGLE_K, chK);
          float coverage = max(max(dotA, dotB), max(dotC, dotK));
          float accentWeight = smoothstep(0.4, 1.0, luminance) * 0.35;
          vec3 dotColor = mix(BASE_COLOR, ACCENT_COLOR, accentWeight);
          vec3 color = mix(BACKGROUND_COLOR, dotColor, coverage);
          gl_FragColor = vec4(color, 1.0);
        }
      `;
      const ppMat = new THREE.ShaderMaterial({
        uniforms: ppUniforms,
        vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.0); }`,
        fragmentShader: ppFrag,
        depthTest: false,
        depthWrite: false,
        transparent: false
      });
      const ppQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), ppMat);
      ppScene.add(ppQuad);

      let mixScene = null;
      let mixCam = null;
      let mixMaterial = null;
      let mixQuad = null;
      let mixTarget = null;

      let blitScene = null;
      let blitCam = null;
      let blitQuad = null;

      const outputMode = 'both';
      const frontVisible = true;
      const backVisible = true;
      const halftoneEnabled = false;

      const onKeyDown = (e) => {
        if (e.key.toLowerCase() === 'r') {
          controls.reset();
          camera.position.set(0.6, 0.8, 3.2);
          controls.target.set(0, groupYOffset, 0);
          controls.update();
        }
      };

      window.addEventListener('keydown', onKeyDown);

      const group = new THREE.Group();
      group.position.y = groupYOffset;
      group.rotation.set(baseRotationX, baseRotationY, 0);
      if (groupScale instanceof THREE.Vector3) {
        group.scale.copy(groupScale);
      } else if (Array.isArray(groupScale) && groupScale.length === 3) {
        group.scale.set(groupScale[0], groupScale[1], groupScale[2]);
      } else if (typeof groupScale === 'number') {
        group.scale.setScalar(groupScale);
      }
      scene.add(group);

      let meshFront = null;
      let meshBack = null;
      let textReady = false;

      const loader = new FontLoader();
      loader.load(fontUrl, (font) => {
        const geoOptions = Object.assign({
          font,
          size: 1.2,
          depth: 0.2,
          curveSegments: 22,
          bevelEnabled: true,
          bevelThickness: 0.1,
          bevelSize: 0.1,
          bevelOffset: 0.0,
          bevelSegments: 18
        }, textOptions);
        const geo = new TextGeometry(text, geoOptions);
        geo.center();

        meshFront = new THREE.Mesh(geo, glassMatFront);
        meshBack = new THREE.Mesh(geo, glassMatBack);
        meshFront.renderOrder = 1;
        meshBack.renderOrder = 0;

        group.add(meshBack);
        group.add(meshFront);

        if (typeof refSceneSetup === 'function') {
          refSceneSetup({ font, refScene, THREE, group, posterMat });
        }

        textReady = true;
      });

      const clock = new THREE.Clock();

      let width = 1;
      let height = 1;
      let dpr = Math.min(window.devicePixelRatio || 1, 2);
      let bgRT = new THREE.WebGLRenderTarget(Math.max(1, width * dpr), Math.max(1, height * dpr));
      glassUniforms.uSceneTex.value = bgRT.texture;
      let frontRT = new THREE.WebGLRenderTarget(Math.max(1, width), Math.max(1, height), { depthBuffer: true });
      let backRT = new THREE.WebGLRenderTarget(Math.max(1, width), Math.max(1, height), { depthBuffer: true });

      let rtWidth = 0;
      let rtHeight = 0;
      let hasSize = false;

      function setupMix() {
        if (mixScene) return;
        mixTarget = new THREE.WebGLRenderTarget(Math.max(1, width), Math.max(1, height));
        mixScene = new THREE.Scene();
        mixCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        mixMaterial = new THREE.ShaderMaterial({
          uniforms: {
            tBack: { value: backRT.texture },
            tFront: { value: frontRT.texture }
          },
          vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=vec4(position,1.0); }`,
          fragmentShader: `varying vec2 vUv; uniform sampler2D tBack; uniform sampler2D tFront; void main(){ vec4 backCol=texture2D(tBack,vUv); vec4 frontCol=texture2D(tFront,vUv); gl_FragColor = max(backCol, frontCol); }`
        });
        mixQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), mixMaterial);
        mixScene.add(mixQuad);
      }

      function blit(tex) {
        if (!blitScene) {
          blitScene = new THREE.Scene();
          blitCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
          blitQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({ map: tex }));
          blitScene.add(blitQuad);
        } else if (blitQuad && blitQuad.material && tex) {
          blitQuad.material.map = tex;
          blitQuad.material.needsUpdate = true;
        }
        localRenderer.render(blitScene, blitCam);
      }

      function resizeTargets(force = false) {
        const newDpr = Math.min(window.devicePixelRatio || 1, 2);
        const dprChanged = Math.abs(newDpr - dpr) > 1e-5;
        const sizeChanged = force || rtWidth !== width || rtHeight !== height || !hasSize;
        if (!dprChanged && !sizeChanged) return;
        dpr = newDpr;
        rtWidth = width;
        rtHeight = height;
        bgRT?.dispose();
        frontRT?.dispose();
        backRT?.dispose();
        bgRT = new THREE.WebGLRenderTarget(Math.max(1, width * dpr), Math.max(1, height * dpr));
        glassUniforms.uSceneTex.value = bgRT.texture;
        frontRT = new THREE.WebGLRenderTarget(Math.max(1, width), Math.max(1, height), { depthBuffer: true });
        backRT = new THREE.WebGLRenderTarget(Math.max(1, width), Math.max(1, height), { depthBuffer: true });
        if (mixTarget) {
          mixTarget.dispose();
          mixTarget = new THREE.WebGLRenderTarget(Math.max(1, width), Math.max(1, height));
        }
        if (mixMaterial) {
          mixMaterial.uniforms.tBack.value = backRT.texture;
          mixMaterial.uniforms.tFront.value = frontRT.texture;
        }
        localRenderer.setPixelRatio(dpr);
        localRenderer.setSize(width, height, false);
        glassUniforms.winResolution.value.set(width, height).multiplyScalar(dpr);
        ppUniforms.resolution.value.set(width, height);
      }

      function render(rect) {
        if (!rect) return;
        const w = Math.max(1, Math.floor(rect.width));
        const h = Math.max(1, Math.floor(rect.height));
        let sizeChanged = false;
        if (w !== width || h !== height) {
          width = w;
          height = h;
          localRenderer.setSize(width, height, false);
          glassUniforms.winResolution.value.set(width, height).multiplyScalar(dpr);
          ppUniforms.resolution.value.set(width, height);
          if (mixScene) {
            mixTarget?.dispose();
            mixTarget = new THREE.WebGLRenderTarget(Math.max(1, width), Math.max(1, height));
            mixMaterial.uniforms.tBack.value = backRT.texture;
            mixMaterial.uniforms.tFront.value = frontRT.texture;
          }
          sizeChanged = true;
        }
        hasSize = true;
        resizeTargets(sizeChanged);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      }

      function update() {
        if (!hasSize) return;
        const t = clock.getElapsedTime();
        controls.update();

        let pointerActive = false;
        let nx = 0;
        let ny = 0;
        if (pointerMode === 'cell') {
          pointerActive = localPointer.active;
          nx = localPointer.nx;
          ny = localPointer.ny;
        } else if (useGlobalPointer && globalPointer.active) {
          pointerActive = true;
          nx = globalPointer.nx;
          ny = globalPointer.ny;
        }
        const targetY = pointerActive ? THREE.MathUtils.clamp(nx * NUMBER_ROT_MAX_Y, -NUMBER_ROT_MAX_Y, NUMBER_ROT_MAX_Y) : 0;
        const targetX = pointerActive ? THREE.MathUtils.clamp(-ny * NUMBER_ROT_MAX_X, -NUMBER_ROT_MAX_X, NUMBER_ROT_MAX_X) : 0;
        const ease = pointerActive ? 0.18 : 0.1;
        pointerRot.currentX += (targetX - pointerRot.currentX) * ease;
        pointerRot.currentY += (targetY - pointerRot.currentY) * ease;
        const baseY = baseRotationY + t * autoRotateSpeed;
        group.rotation.y = baseY + pointerRot.currentY;
        group.rotation.x = baseRotationX + pointerRot.currentX;

        if (zoomState) {
          zoomState.current += (zoomState.target - zoomState.current) * 0.12;
          camera.position.copy(CAMERA_DEFAULT).lerp(CAMERA_HOVER, zoomState.current);
        } else {
          camera.position.copy(CAMERA_DEFAULT);
        }
        camera.lookAt(0, groupYOffset, 0);

        localRenderer.setScissorTest(false);

        localRenderer.setRenderTarget(bgRT);
        localRenderer.clear(true, true, true);
        localRenderer.render(refScene, camera);

        glassUniforms.uSceneTex.value = bgRT.texture;
        glassUniforms.winResolution.value.set(width, height).multiplyScalar(dpr);

        if (meshFront) meshFront.visible = frontVisible;
        if (meshBack) meshBack.visible = false;
        localRenderer.setRenderTarget(frontRT);
        localRenderer.clear(true, true, true);
        localRenderer.render(scene, camera);

        if (meshFront) meshFront.visible = false;
        if (meshBack) meshBack.visible = backVisible;
        localRenderer.setRenderTarget(backRT);
        localRenderer.clear(true, true, true);
        localRenderer.render(scene, camera);

        if (meshFront) meshFront.visible = frontVisible;
        if (meshBack) meshBack.visible = backVisible;
        scene.overrideMaterial = null;

        localRenderer.setRenderTarget(null);
        localRenderer.clear(true, true, true);

        const mode = outputMode;
        if (halftoneEnabled) {
          if (mode === 'front') {
            ppUniforms.uScene.value = frontRT.texture;
          } else if (mode === 'back') {
            ppUniforms.uScene.value = backRT.texture;
          } else {
            setupMix();
            mixMaterial.uniforms.tBack.value = backRT.texture;
            mixMaterial.uniforms.tFront.value = frontRT.texture;
            localRenderer.setRenderTarget(mixTarget);
            localRenderer.clear(true, true, true);
            localRenderer.render(mixScene, mixCam);
            localRenderer.setRenderTarget(null);
            ppUniforms.uScene.value = mixTarget.texture;
          }
          localRenderer.render(ppScene, ppCam);
        } else {
          if (mode === 'front') {
            blit(frontRT.texture);
          } else if (mode === 'back') {
            blit(backRT.texture);
          } else {
            setupMix();
            mixMaterial.uniforms.tBack.value = backRT.texture;
            mixMaterial.uniforms.tFront.value = frontRT.texture;
            localRenderer.render(mixScene, mixCam);
          }
        }

        if (textReady) {
          // optional time based updates for future hooks
        }

        posterMat.uniforms.uTime.value = t;
      }

      if (halftone) {
        console.assert(ppUniforms.pixelSize.value === 10.0, 'pixelSize が 10 ではありません');
        console.assert(ppUniforms.dotSize.value === 0.32, 'dotSize が 0.32 ではありません');
      }
      setTimeout(() => {
        console.assert(glassUniforms.uSceneTex.value === bgRT.texture, 'uSceneTex が bgRT.texture を参照していません');
      }, 500);

      return { render, update, _ascii: true };
    }



    function buildScene3SimpleEffect(cellEl) {
      const mount = document.createElement('div');
      mount.classList.add('scene3-matrix');
      mount.style.display = 'none';
      cellEl.appendChild(mount);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setClearColor(0xffffff, 0);
      mount.appendChild(renderer.domElement);
      renderer.domElement.style.touchAction = 'none';
      renderer.domElement.style.cursor = 'default';

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xdeefff);
      const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
      camera.position.set(0, 0.4, 3.2);

      const ambient = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambient);
      const directional = new THREE.DirectionalLight(0xffffff, 0.65);
      directional.position.set(3.6, 4.6, 6.2);
      scene.add(directional);
      const rim = new THREE.DirectionalLight(0xd8e7ff, 0.35);
      rim.position.set(-4, -3, -5);
      scene.add(rim);

      const group = new THREE.Group();
      group.position.y = 0.12;
      scene.add(group);

      const baseRotX = THREE.MathUtils.degToRad(12);
      group.rotation.x = baseRotX;

      getHelvetikerRegular().then((font) => {
        const geo = new TextGeometry('1', {
          font,
          size: 1.8,
          depth: 0.35,
          curveSegments: 30,
          bevelEnabled: true,
          bevelThickness: 0.07,
          bevelSize: 0.06,
          bevelSegments: 10
        });
        geo.center();

        const material = new THREE.MeshPhysicalMaterial({
          color: 0x024b9e,
          roughness: 0.3,
          metalness: 0.15,
          clearcoat: 0.3,
          clearcoatRoughness: 0.12,
          transmission: 0.05,
          ior: 1.2
        });

        const mesh = new THREE.Mesh(geo, material);
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        group.add(mesh);
      }).catch((err) => console.warn('Failed to load font for Scene3 simple mode', err));

      const pointerRot = { currentX: 0, currentY: 0 };
      const ROT_MAX_X = Math.PI * 0.25;
      const ROT_MAX_Y = Math.PI * 0.35;
      const ROT_EASE_ACTIVE = 0.18;
      const ROT_EASE_IDLE = 0.08;
      const AUTO_ROT_SPEED = 0.5;

      let width = 0;
      let height = 0;
      let disposed = false;

      function resize(rect) {
        const w = Math.max(1, Math.floor(rect.width));
        const h = Math.max(1, Math.floor(rect.height));
        if (w === width && h === height) return;
        width = w;
        height = h;
        renderer.setSize(w, h, false);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }

      return {
        setActive(active) {
          mount.style.display = active ? 'block' : 'none';
        },
        update(t) {
          const active = globalPointer.active;
          const targetY = active ? THREE.MathUtils.clamp(globalPointer.nx * ROT_MAX_Y, -ROT_MAX_Y, ROT_MAX_Y) : 0;
          const targetX = active ? THREE.MathUtils.clamp(-globalPointer.ny * ROT_MAX_X, -ROT_MAX_X, ROT_MAX_X) : 0;
          const ease = active ? ROT_EASE_ACTIVE : ROT_EASE_IDLE;
          pointerRot.currentX += (targetX - pointerRot.currentX) * ease;
          pointerRot.currentY += (targetY - pointerRot.currentY) * ease;
          const baseY = t * AUTO_ROT_SPEED;
          group.rotation.y = baseY + pointerRot.currentY;
          group.rotation.x = baseRotX + pointerRot.currentX * 0.9;
        },
        render(rect) {
          if (!rect) return;
          resize(rect);
          renderer.render(scene, camera);
        },
        dispose() {
          renderer.dispose();
          mount.remove();
        }
      };
    }

    const PIXELATE_VERTEX_SHADER = `varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`;
    const PIXELATE_FRAGMENT_SHADER = `uniform sampler2D tDiffuse;uniform vec2 resolution;uniform vec2 pixelSize;varying vec2 vUv;void main(){vec2 texel=pixelSize / resolution;vec2 pixelatedUV=floor(vUv / texel)*texel;gl_FragColor=texture2D(tDiffuse,pixelatedUV);}`;

    function createPixelateShader({ resolutionUniform, pixelSizeUniform } = {}) {
      const resolution = resolutionUniform ?? new THREE.Vector2(1, 1);
      const pixelSize = pixelSizeUniform ?? new THREE.Vector2(2.0, 2.0);
      return {
        shader: {
          uniforms: {
            tDiffuse: { value: null },
            resolution: { value: resolution },
            pixelSize: { value: pixelSize }
          },
          vertexShader: PIXELATE_VERTEX_SHADER,
          fragmentShader: PIXELATE_FRAGMENT_SHADER
        },
        resolutionUniform: resolution,
        pixelSizeUniform: pixelSize
      };
    }

    function buildScene3ShaderEffect(cellEl) {
      const mount = document.createElement('div');
      mount.classList.add('scene3-matrix');
      mount.style.display = 'none';
      cellEl.appendChild(mount);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setClearColor(0x030712, 1);
      mount.appendChild(renderer.domElement);
      renderer.domElement.style.touchAction = 'none';
      renderer.domElement.style.cursor = 'default';

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x010309, 0.12);

      const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
      camera.position.set(0, 0, 2.2);
      camera.lookAt(0, 0, 0);

      const ambient = new THREE.AmbientLight(0x0d1b2a, 0.6);
      scene.add(ambient);
      const keyLight = new THREE.DirectionalLight(0x4c9fff, 1.8);
      keyLight.position.set(4.5, 6.5, 8);
      scene.add(keyLight);
      const rimLight = new THREE.DirectionalLight(0xff45e1, 0.9);
      rimLight.position.set(-6, -4, -10);
      scene.add(rimLight);
      const fillLight = new THREE.PointLight(0x013984, 0.6, 12, 2);
      fillLight.position.set(0, 1.2, 2.4);
      scene.add(fillLight);

      const numberGroup = new THREE.Group();
      numberGroup.position.y = 0.18;
      scene.add(numberGroup);

      const baseRotX = THREE.MathUtils.degToRad(-12);
      numberGroup.rotation.x = baseRotX;

      getHelvetikerRegular().then((font) => {
        const geo = new TextGeometry('1', {
          font,
          size: 2.2,
          depth: 0.48,
          curveSegments: 32,
          bevelEnabled: true,
          bevelThickness: 0.08,
          bevelSize: 0.06,
          bevelSegments: 12
        });
        geo.center();

        const surfaceMat = new THREE.MeshPhongMaterial({
          color: 0x024b9e,
          specular: 0x8fc7ff,
          shininess: 220,
          emissive: 0x0b2f5f,
          emissiveIntensity: 0.45
        });

        const glowMat = new THREE.MeshPhongMaterial({
          color: 0x3ca6ff,
          emissive: 0x1f6dff,
          emissiveIntensity: 0.75,
          transparent: true,
          opacity: 0.35,
          side: THREE.BackSide
        });

        const mesh = new THREE.Mesh(geo, surfaceMat);
        numberGroup.add(mesh);

        const glow = new THREE.Mesh(geo.clone(), glowMat);
        glow.scale.setScalar(1.06);
        numberGroup.add(glow);
      }).catch((err) => console.warn('Failed to load font for Scene3 shader mode', err));

      const accentGroup = new THREE.Group();
      scene.add(accentGroup);

      const accentColors = [0xff0080, 0xffbf00, 0x00ffbf, 0x8000ff, 0xffff00, 0x00ff00, 0x0000ff, 0xff0000];
      const accentGeometry = new THREE.SphereGeometry(0.24, 16, 16);
      for (let i = 0; i < 18; i++) {
        const material = new THREE.MeshPhongMaterial({
          color: accentColors[i % accentColors.length],
          emissive: 0x111111,
          emissiveIntensity: 0.2,
          shininess: 120,
          transparent: true,
          opacity: 0.8
        });
        const bubble = new THREE.Mesh(accentGeometry, material);
        bubble.position.set((Math.random() - 0.5) * 7, (Math.random() - 0.5) * 7, (Math.random() - 0.5) * 7);
        accentGroup.add(bubble);
      }

      const trailGeometry = new THREE.CylinderGeometry(0.02, 0.02, 6, 8, 1, true);
      const trailMaterial = new THREE.MeshBasicMaterial({
        color: 0x0c4a9e,
        transparent: true,
        opacity: 0.35,
        side: THREE.DoubleSide
      });
      const trails = new THREE.Group();
      for (let i = 0; i < 12; i++) {
        const strip = new THREE.Mesh(trailGeometry, trailMaterial.clone());
        strip.position.set((Math.random() - 0.5) * 8, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 8);
        strip.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        strip.scale.setScalar(0.6 + Math.random() * 0.8);
        trails.add(strip);
      }
      scene.add(trails);

      const composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      const bloomPass = new UnrealBloomPass(new THREE.Vector2(1, 1), 1.2, 0.6, 0.2);
      composer.addPass(bloomPass);

      const { shader: pixelateShader, resolutionUniform: sceneResolutionUniform } = createPixelateShader({
        pixelSizeUniform: new THREE.Vector2(2.0, 2.0)
      });
      const pixelatePass = new ShaderPass(pixelateShader);
      composer.addPass(pixelatePass);

      const scanLineShader = {
        uniforms: {
          tDiffuse: { value: null },
          time: { value: 0.0 },
          resolution: { value: sceneResolutionUniform },
          lineHeight: { value: 12.0 },
          lineSpacing: { value: 5.5 },
          opacity: { value: 0.6 }
        },
        vertexShader: `varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
        fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float time;
    uniform vec2 resolution;
    uniform float lineHeight;
    uniform float lineSpacing;
    uniform float opacity;
    varying vec2 vUv;
    void main(){
      vec4 color = texture2D(tDiffuse, vUv);
      // UV座標をピクセル座標に変換（0〜resolution.y）
      float yPixel = vUv.y * resolution.y;
      float pos = yPixel + time * 120.0;
      float mask = step(lineSpacing, mod(pos, lineHeight));
      vec3 highlight = mix(color.rgb, vec3(1.0), opacity);
      color.rgb = mix(color.rgb, highlight, mask);
      gl_FragColor = color;
    }
  `
      };
      const scanLinePass = new ShaderPass(scanLineShader);
      scanLinePass.material.blending = THREE.NormalBlending;
      composer.addPass(scanLinePass);

      const grainShader = {
        uniforms: {
          tDiffuse: { value: null },
          time: { value: 0.0 }
        },
        vertexShader: `
          varying vec2 vUv;
          void main(){
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform sampler2D tDiffuse;
          uniform float time;
          varying vec2 vUv;
          float hash(vec2 p){
            return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);
          }
          void main(){
            vec4 color = texture2D(tDiffuse, vUv);
            float grain = hash(vUv + vec2(time * 0.13, time * 0.21));
            color.rgb += (grain - 0.5) * 0.05;
            gl_FragColor = color;
          }
        `
      };
      const grainPass = new ShaderPass(grainShader);
      grainPass.renderToScreen = true;
      composer.addPass(grainPass);

      let width = 0;
      let height = 0;
      let currentTime = 0;
      let lastTime = 0;

      const pointerRot = { currentX: 0, currentY: 0 };
      const ROT_MAX_X = Math.PI * 0.22;
      const ROT_MAX_Y = Math.PI * 0.35;
      const ROT_EASE_ACTIVE = 0.18;
      const ROT_EASE_IDLE = 0.08;
      const AUTO_ROT_SPEED = 0.55;

      function resize(rect) {
        const w = Math.max(1, Math.floor(rect.width));
        const h = Math.max(1, Math.floor(rect.height));
        if (w === width && h === height) return;
        width = w;
        height = h;
        renderer.setSize(w, h, false);
        composer.setSize(w, h);
        bloomPass.setSize(w, h);
        pixelatePass.uniforms.resolution.value.set(w, h);
        sceneResolutionUniform.set(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }

      return {
        setActive(active) {
          mount.style.display = active ? 'block' : 'none';
        },
        update(t) {
          currentTime = t;
        },
        render(rect) {
          if (!rect) return;
          resize(rect);

          const dt = Math.max(0, currentTime - lastTime);
          lastTime = currentTime;

          const active = globalPointer.active;
          const targetY = active ? THREE.MathUtils.clamp(globalPointer.nx * ROT_MAX_Y, -ROT_MAX_Y, ROT_MAX_Y) : 0;
          const targetX = active ? THREE.MathUtils.clamp(-globalPointer.ny * ROT_MAX_X, -ROT_MAX_X, ROT_MAX_X) : 0;
          const ease = active ? ROT_EASE_ACTIVE : ROT_EASE_IDLE;
          pointerRot.currentX += (targetX - pointerRot.currentX) * ease;
          pointerRot.currentY += (targetY - pointerRot.currentY) * ease;

          const baseY = currentTime * AUTO_ROT_SPEED;
          numberGroup.rotation.y = baseY + pointerRot.currentY;
          numberGroup.rotation.x = baseRotX + pointerRot.currentX * 0.9;

          accentGroup.rotation.y += dt * 0.45;
          accentGroup.rotation.x += dt * 0.12;
          trails.rotation.z -= dt * 0.2;

          scanLinePass.uniforms.time.value = currentTime;
          grainPass.uniforms.time.value = currentTime;

          composer.render();
        },
        dispose() {
          composer.dispose?.();
          renderer.dispose();
          mount.remove();
        }
      };
    }

    function createScanLineOne(cellEl) {
      if (!cellEl) return null;

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xdeefff);
      const bloomBackground = new THREE.Color(0x000000);

      const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
      camera.position.set(0, 0, 2.2);
      camera.lookAt(0, 0, 0);

      const ambientLight = new THREE.AmbientLight(0xffffff, 1);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xdeefff, 0.8);
      directionalLight.position.set(10, 10, 10);
      scene.add(directionalLight);

      const group = new THREE.Group();
      group.rotation.set(NUMBER_BASE_ROT_X, NUMBER_BASE_ROT_Y, 0);
      scene.add(group);

      const BLOOM_LAYER = 1;
      const bloomLayer = new THREE.Layers();
      bloomLayer.set(BLOOM_LAYER);
      const darkMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
      darkMaterial.toneMapped = false;
      const storedMaterials = Object.create(null);

      const material = new THREE.MeshPhongMaterial({
        transparent: true,
        opacity: 0.7,
        color: 0x024b9e,
        emissive: 0x00152e,
        shininess: 100,
        specular: 0xdeefff
      });

      getHelvetikerRegular()
        .then((font) => {
          const geometry = new TextGeometry('1', {
            font,
            size: 1.4,
            depth: 0.42,
            curveSegments: 8,
            bevelEnabled: true,
            bevelThickness: 0.03,
            bevelSize: 0.02,
            bevelSegments: 2
          });
          geometry.center();
          const mesh = new THREE.Mesh(geometry, material);
          mesh.layers.enable(BLOOM_LAYER);
          group.add(mesh);
        })
        .catch((err) => console.warn('Failed to load font for Scene 3', err));

      if (!cellEl.style.position) cellEl.style.position = 'relative';
      cellEl.style.userSelect = 'none';
      cellEl.style.touchAction = 'none';
      cellEl.style.cursor = 'default';

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.NoToneMapping;
      renderer.setClearColor(0xdeefff, 0);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.domElement.style.width = '100%';
      renderer.domElement.style.height = '100%';
      renderer.domElement.style.display = 'block';
      renderer.domElement.style.touchAction = 'none';
      cellEl.appendChild(renderer.domElement);

      const pointerRot = { currentX: 0, currentY: 0 };
      const darkenNonBloomed = (obj) => {
        if (!obj.isMesh) return;
        if (bloomLayer.test(obj.layers)) return;
        if (storedMaterials[obj.uuid]) return;
        storedMaterials[obj.uuid] = obj.material;
        obj.material = darkMaterial;
      };
      const restoreMaterial = (obj) => {
        if (!obj.isMesh) return;
        const original = storedMaterials[obj.uuid];
        if (!original) return;
        obj.material = original;
        delete storedMaterials[obj.uuid];
      };
      let currentTime = 0;
      let composer = null;
      let bloomComposer = null;
      let renderPass = null;
      let bloomRenderPass = null;
      let bloomPass = null;
      let bloomCompositePass = null;
      let pixelatePass = null;
      let pixelateUniforms = null;
      let scanLinePass = null;
      let grainPass = null;
      let composerInitialized = false;
      const USE_POST = true;
      const ENABLE_SCANLINE = true;
      const resolutionUniform = new THREE.Vector2(1, 1);
      const BASE_PIXEL_SIZE = new THREE.Vector2(5.0, 5.0);
      const HOVER_PIXEL_SIZE = new THREE.Vector2(50.0, 50.0);
      const pixelSizeUniform = BASE_PIXEL_SIZE.clone();
      const pixelSizeTarget = BASE_PIXEL_SIZE.clone();
      let width = 0;
      let height = 0;
      let disposed = false;

      const { shader: pixelateShader } = createPixelateShader({ resolutionUniform, pixelSizeUniform });
      const pointerWithinCell = () => {
        if (!cellEl || !globalPointer.active) return false;
        const rect = cellEl.getBoundingClientRect();
        const w = window.innerWidth || 1;
        const h = window.innerHeight || 1;
        const clientX = ((globalPointer.nx + 1) * 0.5) * w;
        const clientY = ((globalPointer.ny + 1) * 0.5) * h;
        return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
      };

      const scanLineShader = {
        uniforms: {
          tDiffuse: { value: null },
          time: { value: 0.0 },
          resolution: { value: resolutionUniform },
          lineHeight: { value: 8.0 },
          lineSpacing: { value: 5.5 },
          opacity: { value: 0.6 }
        },
        vertexShader: `varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
        fragmentShader: `uniform sampler2D tDiffuse;uniform float time;uniform float lineHeight;uniform float lineSpacing;uniform float opacity;varying vec2 vUv;void main(){vec4 color=texture2D(tDiffuse,vUv);float pos=gl_FragCoord.y+time*120.0;float mask=step(lineSpacing,mod(pos,lineHeight));vec3 highlight=mix(color.rgb,vec3(1.0),opacity);color.rgb=mix(color.rgb,highlight,mask);gl_FragColor=color;}`
      };

      const grainShader = {
        uniforms: {
          tDiffuse: { value: null },
          time: { value: 0.0 }
        },
        vertexShader: `varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
        fragmentShader: `uniform sampler2D tDiffuse;uniform float time;varying vec2 vUv;float random(vec2 p){return fract(sin(dot(p,vec2(12.9898,78.233))+time)*43758.5453);}void main(){vec4 color=texture2D(tDiffuse,vUv);float grain=random(vUv);color.rgb+=(grain-0.5)*0.05;gl_FragColor=color;}`
      };

      const bloomCompositeShader = {
        uniforms: {
          tDiffuse: { value: null },
          bloomTexture: { value: null }
        },
        vertexShader: `varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
        fragmentShader: `uniform sampler2D tDiffuse;uniform sampler2D bloomTexture;varying vec2 vUv;void main(){vec4 base=texture2D(tDiffuse,vUv);vec4 bloom=texture2D(bloomTexture,vUv);gl_FragColor=vec4(base.rgb + bloom.rgb, base.a);}`
      };

      function ensureComposer(width, height) {
        const safeWidth = Math.max(1, Math.floor(width || 1));
        const safeHeight = Math.max(1, Math.floor(height || 1));
        if (!composer) {
          composer = new EffectComposer(renderer);
          renderPass = new RenderPass(scene, camera);
          renderPass.clear = true;
          renderPass.clearDepth = true;
          composer.addPass(renderPass);

          bloomCompositePass = new ShaderPass(bloomCompositeShader);
          composer.addPass(bloomCompositePass);

          pixelatePass = new ShaderPass(pixelateShader);
          composer.addPass(pixelatePass);
          pixelateUniforms = pixelatePass.uniforms || pixelatePass.material?.uniforms || null;

          if (ENABLE_SCANLINE) {
            scanLinePass = new ShaderPass(scanLineShader);
            scanLinePass.material.blending = THREE.NormalBlending;
            composer.addPass(scanLinePass);
            scanLinePass.uniforms.time.value = currentTime * 60.0;
            scanLinePass.uniforms.resolution.value.set(safeWidth, safeHeight);
          }
          grainPass = new ShaderPass(grainShader);
          grainPass.renderToScreen = false;
          composer.addPass(grainPass);
          grainPass.uniforms.time.value = currentTime * 0.5;
        }

        if (!bloomComposer) {
          bloomComposer = new EffectComposer(renderer);
          bloomRenderPass = new RenderPass(scene, camera);
          bloomRenderPass.clear = true;
          bloomRenderPass.clearDepth = true;
          bloomComposer.addPass(bloomRenderPass);

          bloomPass = new UnrealBloomPass(new THREE.Vector2(safeWidth, safeHeight), 3.2, 0.8, 2.0);
          bloomPass.threshold = 0.2;
          bloomComposer.addPass(bloomPass);
        }

        if (renderPass) renderPass.camera = camera;
        if (bloomRenderPass) bloomRenderPass.camera = camera;
        composer.setSize(safeWidth, safeHeight);
        bloomComposer?.setSize(safeWidth, safeHeight);
        bloomPass?.setSize(safeWidth, safeHeight);
        resolutionUniform.set(safeWidth, safeHeight);
        pixelatePass?.uniforms?.resolution?.value?.set(safeWidth, safeHeight);
        if (ENABLE_SCANLINE && scanLinePass) {
          scanLinePass.uniforms.resolution.value.set(safeWidth, safeHeight);
        }
        if (bloomCompositePass && bloomComposer) {
          bloomCompositePass.uniforms.bloomTexture.value =
            (bloomComposer.renderTarget2 && bloomComposer.renderTarget2.texture) ||
            (bloomComposer.renderTarget1 && bloomComposer.renderTarget1.texture) ||
            null;
        }
        composerInitialized = !!(composer && bloomComposer && bloomCompositePass);
      }

      function updateState(t) {
        currentTime = t;
        const active = globalPointer.active;
        const targetY = active
          ? THREE.MathUtils.clamp(globalPointer.nx * NUMBER_ROT_MAX_Y, -NUMBER_ROT_MAX_Y, NUMBER_ROT_MAX_Y)
          : 0;
        const targetX = active
          ? THREE.MathUtils.clamp(-globalPointer.ny * NUMBER_ROT_MAX_X, -NUMBER_ROT_MAX_X, NUMBER_ROT_MAX_X)
          : 0;
        const ease = active ? 0.18 : 0.12;
        pointerRot.currentX += (targetX - pointerRot.currentX) * ease;
        pointerRot.currentY += (targetY - pointerRot.currentY) * ease;

        const baseY = NUMBER_BASE_ROT_Y + t * NUMBER_AUTO_ROT_SPEED;
        group.rotation.y = baseY + pointerRot.currentY;
        group.rotation.x = NUMBER_BASE_ROT_X + pointerRot.currentX;
        if (pointerWithinCell()) {
          pixelSizeTarget.copy(HOVER_PIXEL_SIZE);
        } else {
          pixelSizeTarget.copy(BASE_PIXEL_SIZE);
        }
        pixelSizeUniform.lerp(pixelSizeTarget, 0.08);

        if (ENABLE_SCANLINE && composerInitialized && scanLinePass) {
          scanLinePass.uniforms.time.value = currentTime * 60.0;
        }
        if (composerInitialized && grainPass) {
          grainPass.uniforms.time.value = currentTime * 0.5;
        }
        if (pixelateUniforms?.pixelSize?.value) {
          pixelateUniforms.pixelSize.value.copy(pixelSizeUniform);
        }
      }

      function renderFrame() {
        if (!width || !height) return;
        if (!USE_POST) {
          renderer.render(scene, camera);
          return;
        }
        ensureComposer(width, height);
        if (!composerInitialized) return;
        const prevAutoClear = renderer.autoClear;
        renderer.autoClear = true;
        const previousBackground = scene.background;
        scene.background = bloomBackground;
        scene.traverse(darkenNonBloomed);
        bloomComposer?.render();
        scene.traverse(restoreMaterial);
        scene.background = previousBackground;
        if (bloomCompositePass && bloomComposer) {
          const bloomTexture =
            (bloomComposer.renderTarget2 && bloomComposer.renderTarget2.texture) ||
            (bloomComposer.renderTarget1 && bloomComposer.renderTarget1.texture) ||
            null;
          bloomCompositePass.uniforms.bloomTexture.value = bloomTexture;
        }
        composer.render();
        renderer.autoClear = prevAutoClear;
      }

      return {
        resize(newWidth, newHeight) {
          width = Math.max(1, Math.floor(newWidth));
          height = Math.max(1, Math.floor(newHeight));
          renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
          renderer.setSize(width, height, false);
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          ensureComposer(width, height);
        },
        tick(time) {
          if (disposed) return;
          updateState(time);
          renderFrame();
        },
        dispose() {
          if (disposed) return;
          disposed = true;
          composer?.passes?.forEach((pass) => pass.dispose?.());
          composer?.dispose?.();
          bloomComposer?.passes?.forEach((pass) => pass.dispose?.());
          bloomComposer?.dispose?.();
          darkMaterial.dispose?.();
          composer = null;
          bloomComposer = null;
          renderPass = null;
          bloomRenderPass = null;
          bloomPass = null;
          bloomCompositePass = null;
          pixelatePass = null;
          pixelateUniforms = null;
          pixelSizeUniform.copy(BASE_PIXEL_SIZE);
          pixelSizeTarget.copy(BASE_PIXEL_SIZE);
          scanLinePass = null;
          grainPass = null;
          composerInitialized = false;
          if (renderer.domElement.parentNode) {
            renderer.domElement.parentNode.removeChild(renderer.domElement);
          }
          renderer.dispose();
        }
      };
    }

    function createContactCurtain(cellEl) {
      if (!cellEl) return null;

      if (!cellEl.style.position) cellEl.style.position = 'relative';

      const container = document.createElement('div');
      container.classList.add('contact-curtain');
      container.style.position = 'absolute';
      container.style.inset = '0';
      container.style.pointerEvents = 'auto';
      container.style.display = 'flex';
      container.style.flexDirection = 'column';
      container.style.alignItems = 'stretch';
      cellEl.appendChild(container);

      const canvas = document.createElement('canvas');
      canvas.classList.add('contact-curtain_canvas');
      canvas.style.flex = '1';
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      canvas.style.display = 'block';
      canvas.style.pointerEvents = 'auto';
      canvas.style.position = 'absolute';
      canvas.style.inset = '0';
      canvas.style.zIndex = '1';
      container.appendChild(canvas);

      const overlay = document.createElement('div');
      overlay.classList.add('contact-curtain_overlay');
      overlay.style.position = 'absolute';
      overlay.style.inset = '0';
      overlay.style.zIndex = '0';
      overlay.style.display = 'flex';
      overlay.style.flexDirection = 'column';
      overlay.style.alignItems = 'center';
      overlay.style.justifyContent = 'center';
      overlay.style.gap = '1.2rem';
      overlay.style.pointerEvents = 'none';
      container.appendChild(overlay);

      const title = document.createElement('h2');
      title.textContent = 'Contact';
      title.style.margin = '0';
      title.style.fontSize = 'clamp(32px, 4vw, 52px)';
      title.style.fontWeight = '800';
      title.style.letterSpacing = '0.06em';
      title.style.textAlign = 'center';
      title.style.color = '#024b9e';
      overlay.appendChild(title);

      const visualButton = document.createElement('span');
      visualButton.textContent = 'contact in X';
      visualButton.style.display = 'inline-flex';
      visualButton.style.alignItems = 'center';
      visualButton.style.justifyContent = 'center';
      visualButton.style.padding = '0.55rem 1.6rem';
      visualButton.style.marginTop = '1.2rem';
      visualButton.style.borderRadius = '999px';
      visualButton.style.background = '#024b9e';
      visualButton.style.color = '#ffffff';
      visualButton.style.fontWeight = '700';
      visualButton.style.fontSize = 'clamp(14px, 2.2vw, 18px)';
      visualButton.style.textTransform = 'uppercase';
      visualButton.style.letterSpacing = '0.08em';
      visualButton.style.textDecoration = 'none';
      visualButton.style.boxShadow = '0 8px 24px rgba(2, 75, 158, 0.28)';
      visualButton.style.pointerEvents = 'none';
      visualButton.style.transition = 'transform 180ms ease, box-shadow 180ms ease, background 180ms ease';
      const buttonWrap = document.createElement('div');
      buttonWrap.style.pointerEvents = 'auto';
      buttonWrap.style.display = 'flex';
      buttonWrap.appendChild(visualButton);
      overlay.appendChild(buttonWrap);

      const hitLink = document.createElement('a');
      hitLink.href = 'https://x.com/321kn';
      hitLink.target = '_blank';
      hitLink.rel = 'noopener noreferrer';
      hitLink.textContent = 'contact in X';
      hitLink.style.position = 'absolute';
      hitLink.style.opacity = '0';
      hitLink.style.pointerEvents = 'auto';
      hitLink.style.display = 'block';
      hitLink.style.zIndex = '3';
      hitLink.style.borderRadius = '999px';
      hitLink.style.cursor = 'pointer';
      container.appendChild(hitLink);

      const setVisualHover = (active) => {
        if (active) {
          visualButton.style.transform = 'translateY(-2px)';
          visualButton.style.boxShadow = '0 12px 28px rgba(2, 75, 158, 0.36)';
          visualButton.style.background = '#146ef5';
        } else {
          visualButton.style.transform = 'translateY(0)';
          visualButton.style.boxShadow = '0 8px 24px rgba(2, 75, 158, 0.28)';
          visualButton.style.background = '#024b9e';
        }
      };

      const syncButtonHit = () => {
        const visualRect = visualButton.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        const width = Math.max(visualRect.width, 1);
        const height = Math.max(visualRect.height, 1);
        hitLink.style.left = `${visualRect.left - containerRect.left}px`;
        hitLink.style.top = `${visualRect.top - containerRect.top}px`;
        hitLink.style.width = `${width}px`;
        hitLink.style.height = `${height}px`;
      };
      const handleResize = () => syncButtonHit();
      const resizeObserver = window.ResizeObserver
        ? new ResizeObserver(() => syncButtonHit())
        : null;
      resizeObserver?.observe(container);
      resizeObserver?.observe(visualButton);
      hitLink.addEventListener('pointerenter', () => setVisualHover(true));
      hitLink.addEventListener('pointerleave', () => setVisualHover(false));
      hitLink.addEventListener('focus', () => setVisualHover(true));
      hitLink.addEventListener('blur', () => setVisualHover(false));
      window.addEventListener('resize', handleResize, { passive: true });
      requestAnimationFrame(syncButtonHit);

      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.NoToneMapping;
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setClearColor(0xdeefff, 0);

      const scene = new THREE.Scene();
      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

      let disposed = false;

      class Vec2 {
        constructor(x = 0, y = 0) { this.x = x; this.y = y; }
        set(x, y) { this.x = x; this.y = y; return this; }
        copy(v) { this.x = v.x; this.y = v.y; return this; }
        add(v) { this.x += v.x; this.y += v.y; return this; }
        sub(v) { this.x -= v.x; this.y -= v.y; return this; }
        scale(s) { this.x *= s; this.y *= s; return this; }
        clone() { return new Vec2(this.x, this.y); }
        length() { return Math.hypot(this.x, this.y); }
      }

      class Particle {
        constructor(x, y) {
          this.pos = new Vec2(x, y);
          this.prev = new Vec2(x, y);
          this.pinned = false;
          this.pinPos = new Vec2(x, y);
        }
        integrate(gravity, dt2, damping) {
          if (this.pinned) {
            this.pos.copy(this.pinPos);
            this.prev.copy(this.pinPos);
            return;
          }
          const nextX = this.pos.x + (this.pos.x - this.prev.x) * damping + gravity.x * dt2;
          const nextY = this.pos.y + (this.pos.y - this.prev.y) * damping + gravity.y * dt2;
          this.prev.set(this.pos.x, this.pos.y);
          this.pos.set(nextX, nextY);
        }
        pin(x = this.pos.x, y = this.pos.y) {
          this.pinned = true;
          this.pinPos.set(x, y);
          this.pos.set(x, y);
          this.prev.set(x, y);
        }
      }

      class DistanceConstraint {
        constructor(p1, p2, restLength, stiffness) {
          this.p1 = p1;
          this.p2 = p2;
          this.rest = restLength;
          this.stiffness = Math.max(stiffness, 0.05);
        }
        solve() {
          const passes = Math.max(1, Math.floor(this.stiffness * 0.2));
          const strength = Math.min(this.stiffness, 1);
          for (let pass = 0; pass < passes; pass++) {
            const dx = this.p2.pos.x - this.p1.pos.x;
            const dy = this.p2.pos.y - this.p1.pos.y;
            const dist = Math.hypot(dx, dy);
            if (!Number.isFinite(dist) || dist < 1e-6) break;
            const diff = (dist - this.rest) / dist;
            const scalar = 0.5 * strength;
            const offsetX = dx * diff * scalar;
            const offsetY = dy * diff * scalar;
            if (!this.p1.pinned) {
              this.p1.pos.x += offsetX;
              this.p1.pos.y += offsetY;
            }
            if (!this.p2.pinned) {
              this.p2.pos.x -= offsetX;
              this.p2.pos.y -= offsetY;
            }
          }
        }
      }

      class LineSegment {
        constructor(points, stiffness) {
          this.particles = points.map((pt) => new Particle(pt.x, pt.y));
          this.constraints = [];
          this.stiffnessFactor = Math.max(stiffness, 0.05);
          for (let i = 1; i < this.particles.length; i++) {
            const pA = this.particles[i - 1];
            const pB = this.particles[i];
            const rest = Math.hypot(pB.pos.x - pA.pos.x, pB.pos.y - pA.pos.y);
            this.constraints.push(new DistanceConstraint(pA, pB, rest, this.stiffnessFactor));
          }
        }
        integrate(gravity, dt2, damping) {
          for (let i = 0; i < this.particles.length; i++) {
            this.particles[i].integrate(gravity, dt2, damping);
          }
        }
        solve(iterations) {
          const stiffnessBoost = 0.6 + Math.log2(1 + this.stiffnessFactor) * 0.7;
          const localIterations = Math.max(1, Math.round(iterations * stiffnessBoost));
          for (let iter = 0; iter < localIterations; iter++) {
            for (let i = 0; i < this.constraints.length; i++) {
              this.constraints[i].solve();
            }
          }
        }
        pin(index) {
          const p = this.particles[index];
          if (p) p.pin();
        }
      }

      class SimpleVerlet {
        constructor(gravity) {
          this.gravity = gravity;
          this.segments = [];
          this.iterations = 12;
          this.damping = 0.995;
        }
        lineSegments(points, stiffness) {
          const seg = new LineSegment(points, Math.max(stiffness, 0.1));
          this.segments.push(seg);
          return seg;
        }
        frame(dt) {
          const dtSeconds = Math.max(0.001, Math.min(0.05, dt));
          const dt2 = dtSeconds * dtSeconds;
          for (let i = 0; i < this.segments.length; i++) {
            this.segments[i].integrate(this.gravity, dt2, this.damping);
          }
          for (let i = 0; i < this.segments.length; i++) {
            this.segments[i].solve(this.iterations);
          }
        }
      }

      const lerpColor = (a, b, t) => {
        return new THREE.Color().copy(a).lerp(b, THREE.MathUtils.clamp(t, 0, 1));
      };

      class Polyline {
        constructor(params) {
          const { points, color1, color2, uvx, uvdx } = params;
          this.points = points;
          this.count = points.length;
          this.color1 = color1.clone();
          this.color2 = color2.clone();
          this.uvx = uvx;
          this.uvdx = uvdx;
          this.init();
          this.updateGeometry();
        }
        init() {
          const count = this.count;
          this.geometry = new THREE.BufferGeometry();
          this.position = new Float32Array(count * 3 * 2);
          this.prev = new Float32Array(count * 3 * 2);
          this.next = new Float32Array(count * 3 * 2);
          const side = new Float32Array(count * 2);
          const uv = new Float32Array(count * 4);
          const color = new Float32Array(count * 6);
          const index = new Uint16Array((count - 1) * 6);

          const colorFromLerp = (t) => lerpColor(this.color1, this.color2, t);
          for (let i = 0; i < count; i++) {
            const i2 = i * 2;
            side[i2] = -1;
            side[i2 + 1] = 1;
            const v = 1 - i / (count - 1);
            uv[i * 4] = this.uvx;
            uv[i * 4 + 1] = v;
            uv[i * 4 + 2] = this.uvx - this.uvdx;
            uv[i * 4 + 3] = v;
            const col = colorFromLerp(v);
            col.toArray(color, i2 * 3);
            col.toArray(color, (i2 + 1) * 3);
            if (i === count - 1) continue;
            index[(i2) * 3 + 0] = i2;
            index[(i2) * 3 + 1] = i2 + 1;
            index[(i2) * 3 + 2] = i2 + 2;
            index[(i2 + 1) * 3 + 0] = i2 + 2;
            index[(i2 + 1) * 3 + 1] = i2 + 1;
            index[(i2 + 1) * 3 + 2] = i2 + 3;
          }

          this.geometry.setAttribute('position', new THREE.BufferAttribute(this.position, 3));
          this.geometry.setAttribute('prev', new THREE.BufferAttribute(this.prev, 3));
          this.geometry.setAttribute('next', new THREE.BufferAttribute(this.next, 3));
          this.geometry.setAttribute('side', new THREE.BufferAttribute(side, 1));
          this.geometry.setAttribute('uv', new THREE.BufferAttribute(uv, 2));
          this.geometry.setAttribute('color', new THREE.BufferAttribute(color, 3));
          this.geometry.setIndex(new THREE.BufferAttribute(index, 1));
          this.geometry.frustumCulled = false;
        }
        updateGeometry() {
          const tmp = new THREE.Vector3();
          for (let i = 0; i < this.count; i++) {
            const p = this.points[i];
            const i2 = i * 2;
            p.toArray(this.position, i2 * 3);
            p.toArray(this.position, i2 * 3 + 3);
            if (i === 0) {
              tmp.copy(p).sub(this.points[i + 1]).add(p);
              tmp.toArray(this.prev, i2 * 3);
              tmp.toArray(this.prev, i2 * 3 + 3);
            } else {
              p.toArray(this.next, (i - 1) * 3 * 2);
              p.toArray(this.next, (i - 1) * 3 * 2 + 3);
            }
            if (i === this.points.length - 1) {
              tmp.copy(p).sub(this.points[i - 1]).add(p);
              tmp.toArray(this.next, i2 * 3);
              tmp.toArray(this.next, i2 * 3 + 3);
            } else {
              p.toArray(this.prev, (i + 1) * 3 * 2);
              p.toArray(this.prev, (i + 1) * 3 * 2 + 3);
            }
          }
          this.geometry.attributes.position.needsUpdate = true;
          this.geometry.attributes.prev.needsUpdate = true;
          this.geometry.attributes.next.needsUpdate = true;
        }
        updateColors(color1, color2) {
          this.color1.copy(color1);
          this.color2.copy(color2);
          const colorAttr = this.geometry.getAttribute('color');
          if (!colorAttr) return;
          for (let i = 0; i < this.count; i++) {
            const t = 1 - i / (this.count - 1);
            const col = lerpColor(this.color1, this.color2, t);
            col.toArray(colorAttr.array, i * 6 + 0);
            col.toArray(colorAttr.array, i * 6 + 3);
          }
          colorAttr.needsUpdate = true;
        }
      }

      const conf = {
        width: 256,
        height: 256,
        nx: 20,
        ny: 20,
        gravity: -400,
        size: 1,
        stiffness: 12,
        mouseRadius: 20,
        mouseStrength: 0.2
      };

      const verlet = new SimpleVerlet(new Vec2(0, conf.gravity));
      const uCx = { value: 2 / conf.width };
      const uCy = { value: 2 / conf.height };
      const uniforms = {
        uCx,
        uCy,
        uSize: { value: conf.size / conf.nx }
      };
      const vertexShader = `
        uniform float uCx;
        uniform float uCy;
        uniform float uSize;
        attribute vec3 color;
        attribute vec3 next;
        attribute vec3 prev;
        attribute float side;

        varying vec2 vUv;
        varying vec4 vColor;

        void main() {
          vUv = uv;
          vColor = vec4(color, 1.0);

          vec3 pos = vec3(position.x * uCx, position.y * uCy, 0.0);
          vec2 sprev = vec2(prev.x * uCx, prev.y * uCy);
          vec2 snext = vec2(next.x * uCx, next.y * uCy);

          vec2 tangent = normalize(snext - sprev);
          vec2 normal = vec2(-tangent.y, tangent.x);

          float dist = length(snext - sprev);
          normal *= smoothstep(0.0, 0.03, dist);
          normal *= uSize;
          pos.xy -= normal * side;

          gl_Position = vec4(pos, 1.0);
        }
      `;
      const fragmentShader = `
        precision mediump float;
        varying vec2 vUv;
        varying vec4 vColor;
        void main() {
          gl_FragColor = vColor;
        }
      `;

      const curtainMaterial = new THREE.ShaderMaterial({
        uniforms,
        vertexShader,
        fragmentShader,
        transparent: true,
        depthTest: false,
        depthWrite: false
      });

      const polylines = [];
      const columnColors = [];
      const updatePoints = () => {
        for (let i = 0; i < polylines.length; i++) {
          const line = polylines[i];
          const seg = line.segment;
          for (let j = 0; j < line.points.length; j++) {
            const particle = seg.particles[j];
            line.points[j].set(particle.pos.x, particle.pos.y, 0);
          }
          line.updateGeometry();
        }
      };
      const baseColorA = new THREE.Color(0x024b9e);
      const baseColorB = new THREE.Color(0x024b9e);
      const tempColor = new THREE.Color();

      const dx = conf.width / conf.nx;
      const dy = -conf.height / (conf.ny - 1);
      const offsetX = -dx * (conf.nx / 2 - 0.5);
      const offsetY = conf.height / 2 - dy / 2;

      const randomColor = () => new THREE.Color(0x024b9e);

      for (let i = 0; i < conf.nx; i++) {
        const points = [];
        const vpoints = [];
        for (let j = 0; j < conf.ny; j++) {
          const x = offsetX + i * dx;
          const y = offsetY + j * dy;
          points.push(new THREE.Vector3(x, y, 0));
          vpoints.push(new Vec2(x, y));
        }
        const color1 = lerpColor(baseColorA, baseColorB, THREE.MathUtils.randFloat(0, 1));
        const color2 = lerpColor(baseColorA, baseColorB, THREE.MathUtils.randFloat(0, 1));
        columnColors.push({ color1, color2 });
        const polyline = new Polyline({
          points,
          color1,
          color2,
          uvx: (i + 1) / conf.nx,
          uvdx: conf.size / conf.nx
        });
        polylines.push(polyline);
        const segment = verlet.lineSegments(vpoints, conf.stiffness);
        segment.pin(0);
        polyline.segment = segment;
        const mesh = new THREE.Mesh(polyline.geometry, curtainMaterial);
        mesh.frustumCulled = false;
        scene.add(mesh);
      }

      for (let i = 0; i < polylines.length; i++) {
        const seg = polylines[i].segment;
        const sway = Math.sin((i / conf.nx) * Math.PI * 2) * 6;
        for (let j = 1; j < seg.particles.length; j++) {
          const factor = 1 - j / (seg.particles.length - 1);
          seg.particles[j].pos.x += sway * factor;
          seg.particles[j].prev.x = seg.particles[j].pos.x - sway * factor * 0.35;
        }
      }
      updatePoints();
      for (let i = 0; i < 180; i++) {
        verlet.frame(0.016);
      }
      updatePoints();

      const mouse = new THREE.Vector2();
      const oldMouse = new THREE.Vector2();
      let hover = false;
      let lastSimTime = null;
      let currentWidth = 1;
      let currentHeight = 1;
      let canvasRect = canvas.getBoundingClientRect();

      const toSimSpace = (clientX, clientY) => {
        const rect = canvasRect;
        const nx = (clientX - rect.left) / Math.max(rect.width, 1);
        const ny = (clientY - rect.top) / Math.max(rect.height, 1);
        const x = (nx - 0.5) * conf.width;
        const y = (0.5 - ny) * conf.height;
        return { x, y };
      };

      const updateMousePosition = (event) => {
        const next = toSimSpace(event.clientX, event.clientY);
        oldMouse.copy(mouse);
        mouse.set(next.x, next.y);
      };

      const applyMouseInfluence = (prev, next) => {
        polylines.forEach((line) => {
          const particles = line.segment.particles;
          for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            const dx = p.pos.x - prev.x;
            const dy = p.pos.y - prev.y;
            const dist = Math.hypot(dx, dy);
            if (dist < conf.mouseRadius) {
              const influence = THREE.MathUtils.clamp(1 - dist / conf.mouseRadius, 0, 1);
              p.pos.x += (next.x - prev.x) * conf.mouseStrength * influence;
              p.pos.y += (next.y - prev.y) * conf.mouseStrength * influence;
            }
          }
        });
      };

      const handlePointerEnter = (event) => {
        hover = true;
        canvasRect = canvas.getBoundingClientRect();
        updateMousePosition(event);
      };
      const handlePointerMove = (event) => {
        if (!hover) return;
        canvasRect = canvas.getBoundingClientRect();
        updateMousePosition(event);
        applyMouseInfluence(oldMouse, mouse);
      };
      const handlePointerLeave = () => {
        hover = false;
      };
      canvas.addEventListener('pointerenter', handlePointerEnter);
      canvas.addEventListener('pointermove', handlePointerMove);
      canvas.addEventListener('pointerleave', handlePointerLeave);

      const stepSimulation = (time) => {
        if (lastSimTime === null) {
          lastSimTime = time;
          return;
        }
        const dt = THREE.MathUtils.clamp(time - lastSimTime, 0.008, 0.03);
        lastSimTime = time;
        verlet.frame(dt);
        updatePoints();
      };

      return {
        update(t) {
          if (disposed) return;
          stepSimulation(t);
        },
        render(rect) {
          if (disposed) return;
          const w = Math.max(1, Math.floor(rect?.width || 1));
          const h = Math.max(1, Math.floor(rect?.height || 1));
          if (w !== currentWidth || h !== currentHeight) {
            currentWidth = w;
            currentHeight = h;
            renderer.setSize(w, h, false);
            canvasRect = canvas.getBoundingClientRect();
          }
          renderer.render(scene, camera);
        },
        _ascii: true,
        dispose() {
          if (disposed) return;
          disposed = true;
          canvas.removeEventListener('pointerenter', handlePointerEnter);
          canvas.removeEventListener('pointermove', handlePointerMove);
          canvas.removeEventListener('pointerleave', handlePointerLeave);
          window.removeEventListener('resize', handleResize);
          resizeObserver?.disconnect?.();
          setVisualHover(false);
          hitLink.remove();
          renderer.dispose();
          curtainMaterial.dispose();
          polylines.forEach((line) => line.geometry.dispose());
          canvas.remove();
          overlay.remove();
          container.remove();
        }
      };
    }

    // function createNumber2() {
    //   const scene = new THREE.Scene();
    //   const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
    //   camera.position.set(0, 0, 4);

    //   // ライティング
    //   const ambientLight = new THREE.AmbientLight(0x404040);
    //   scene.add(ambientLight);

    //   const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    //   directionalLight.position.set(1, 1, 1);
    //   scene.add(directionalLight);

    //   const pointLight = new THREE.PointLight(0x4080ff, 2, 100);
    //   pointLight.position.set(0, 1, 2);
    //   scene.add(pointLight);

    //   // グループを作成（回転用）
    //   const group = new THREE.Group();
    //   scene.add(group);

    //   // フォントローダーとテキストジオメトリ
    //   // 注意: FontLoaderとTextGeometryは外部ライブラリが必要なため、
    //   // 代替として基本的なジオメトリで「2」を構築します

    //   // マテリアル（グラデーション効果のあるマテリアル）
    //   const material = new THREE.MeshPhongMaterial({
    //     color: 0x4080ff,
    //     emissive: 0x072534,
    //     specular: 0x111111,
    //     shininess: 100,
    //     flatShading: false
    //   });

    //   // 「2」の形状を複数のボックスジオメトリで作成
    //   const createNumber2 = () => {
    //     const number = new THREE.Group();

    //     // 2の上部の横棒
    //     const top = new THREE.Mesh(
    //       new THREE.BoxGeometry(1.2, 0.2, 0.3),
    //       material
    //     );
    //     top.position.set(0, 1, 0);
    //     number.add(top);

    //     // 2の右側の縦棒
    //     const right = new THREE.Mesh(
    //       new THREE.BoxGeometry(0.2, 0.6, 0.3),
    //       material
    //     );
    //     right.position.set(0.5, 0.7, 0);
    //     number.add(right);

    //     // 2の中央の横棒
    //     const middle = new THREE.Mesh(
    //       new THREE.BoxGeometry(1.2, 0.2, 0.3),
    //       material
    //     );
    //     middle.position.set(0, 0.1, 0);
    //     number.add(middle);

    //     // 2の左側の縦棒
    //     const left = new THREE.Mesh(
    //       new THREE.BoxGeometry(0.2, 0.6, 0.3),
    //       material
    //     );
    //     left.position.set(-0.5, -0.2, 0);
    //     number.add(left);

    //     // 2の下部の横棒
    //     const bottom = new THREE.Mesh(
    //       new THREE.BoxGeometry(1.2, 0.2, 0.3),
    //       material
    //     );
    //     bottom.position.set(0, -0.5, 0);
    //     number.add(bottom);

    //     // 上部の曲線部分（円弧の近似）
    //     const curve1 = new THREE.Mesh(
    //       new THREE.BoxGeometry(0.15, 0.15, 0.3),
    //       material
    //     );
    //     curve1.position.set(0.45, 0.95, 0);
    //     curve1.rotation.z = Math.PI / 6;
    //     number.add(curve1);

    //     const curve2 = new THREE.Mesh(
    //       new THREE.BoxGeometry(0.15, 0.15, 0.3),
    //       material
    //     );
    //     curve2.position.set(-0.45, 0.95, 0);
    //     curve2.rotation.z = -Math.PI / 6;
    //     number.add(curve2);

    //     // 下部の曲線部分
    //     const curve3 = new THREE.Mesh(
    //       new THREE.BoxGeometry(0.15, 0.15, 0.3),
    //       material
    //     );
    //     curve3.position.set(0.45, -0.45, 0);
    //     curve3.rotation.z = -Math.PI / 6;
    //     number.add(curve3);

    //     const curve4 = new THREE.Mesh(
    //       new THREE.BoxGeometry(0.15, 0.15, 0.3),
    //       material
    //     );
    //     curve4.position.set(-0.45, -0.45, 0);
    //     curve4.rotation.z = Math.PI / 6;
    //     number.add(curve4);

    //     return number;
    //   };

    //   // より滑らかな「2」を作成（代替案：シリンダーと球を使用）
    //   const createSmoothNumber2 = () => {
    //     const number = new THREE.Group();
    //     const segments = 32;

    //     // トーラスで上部の曲線を表現
    //     const topCurve = new THREE.Mesh(
    //       new THREE.TorusGeometry(0.5, 0.15, 8, segments, Math.PI),
    //       material
    //     );
    //     topCurve.position.set(0, 0.8, 0);
    //     topCurve.rotation.z = Math.PI;
    //     number.add(topCurve);

    //     // 斜めの中央部分
    //     const diagonal = new THREE.Mesh(
    //       new THREE.BoxGeometry(0.3, 1.2, 0.3),
    //       material
    //     );
    //     diagonal.position.set(0.2, 0, 0);
    //     diagonal.rotation.z = -Math.PI / 6;
    //     number.add(diagonal);

    //     // 下部の横棒
    //     const bottomBar = new THREE.Mesh(
    //       new THREE.BoxGeometry(1.4, 0.3, 0.3),
    //       material
    //     );
    //     bottomBar.position.set(0, -0.8, 0);
    //     number.add(bottomBar);

    //     return number;
    //   };

    //   // メインの「2」を作成してグループに追加
    //   const number2 = createSmoothNumber2();
    //   group.add(number2);

    //   // ミラー効果（反射）を追加
    //   const mirror = number2.clone();
    //   mirror.position.y = -2;
    //   mirror.rotation.x = Math.PI;
    //   mirror.scale.y = 0.8;

    //   // 半透明のマテリアルでミラー効果
    //   const mirrorMaterial = material.clone();
    //   mirrorMaterial.opacity = 0.3;
    //   mirrorMaterial.transparent = true;
    //   mirror.traverse((child) => {
    //     if (child.isMesh) {
    //       child.material = mirrorMaterial;
    //     }
    //   });
    //   group.add(mirror);

    //   // パーティクル効果を追加
    //   const particlesGeometry = new THREE.BufferGeometry();
    //   const particlesCount = 200;
    //   const positions = new Float32Array(particlesCount * 3);

    //   for (let i = 0; i < particlesCount * 3; i += 3) {
    //     positions[i] = (Math.random() - 0.5) * 5;
    //     positions[i + 1] = (Math.random() - 0.5) * 5;
    //     positions[i + 2] = (Math.random() - 0.5) * 3;
    //   }

    //   particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    //   const particlesMaterial = new THREE.PointsMaterial({
    //     color: 0x4080ff,
    //     size: 0.02,
    //     transparent: true,
    //     opacity: 0.6
    //   });

    //   const particles = new THREE.Points(particlesGeometry, particlesMaterial);
    //   scene.add(particles);

    //   return {
    //     scene,
    //     camera,
    //     update(t) {
    //       // メインの自転
    //       group.rotation.y = t * 0.5;

    //       // 上下の揺れ
    //       group.position.y = Math.sin(t * 0.8) * 0.1;

    //       // カメラの微妙な動き
    //       camera.position.x = Math.sin(t * 0.3) * 0.5;
    //       camera.position.y = Math.cos(t * 0.2) * 0.3;
    //       camera.lookAt(0, 0, 0);

    //       // パーティクルの回転
    //       particles.rotation.y = t * 0.1;
    //       particles.rotation.x = t * 0.05;

    //       // ライトの色の変化
    //       const hue = (t * 0.1) % 1;
    //       pointLight.color.setHSL(hue, 0.8, 0.5);
    //     }
    //   };
    // }
    function createImage(cellEl) {
      if (!cellEl) return null;

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
      camera.position.set(0, 0, 2.6);

      const geometry = new THREE.PlaneGeometry(3.0, 3.0);
      const loader = new THREE.TextureLoader();
      const src = cellEl.dataset?.img || '';
      const uniforms = {
        uTex: { value: null },
        imageAspectRatio: { value: 1.0 },
        aspectRatio: { value: 1.0 },
        opacity: { value: 1.0 },
        hover: { value: 0.0 },
        uGlitch: { value: 0.0 },
        uTime: { value: 0.0 },
        uExposure: { value: 1.20 },
        uSaturation: { value: 0.85 },
        uWash: { value: 0.10 },
      };

      const tex = loader.load(src, (loaded) => {
        if (loaded.image && loaded.image.width && loaded.image.height) {
          uniforms.uTex.value = loaded;
          uniforms.imageAspectRatio.value = loaded.image.width / loaded.image.height;
        }
      });
      tex.colorSpace = THREE.SRGBColorSpace;

      const vertexShader = `
        varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `;
      const fragmentShader = `
        precision highp float;
        uniform sampler2D uTex;
        uniform float imageAspectRatio;
        uniform float aspectRatio;
        uniform float opacity;
        uniform float hover;
        uniform float uGlitch;
        uniform float uTime;
        uniform float uExposure;
        uniform float uSaturation;
        uniform float uWash;
        varying vec2 vUv;
        float exponentialInOut(float t){
          return t == 0.0 || t == 1.0 ? t : (t < 0.5 ? 0.5 * pow(2.0, (20.0 * t) - 10.0) : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0);
        }
        void main(){
          vec2 uv = vUv;
          float u = imageAspectRatio / aspectRatio;
          if (imageAspectRatio > aspectRatio) { u = 1.0 / u; }
          uv.y *= u;
          uv.y -= (u)/2.0 - 0.5;
          float zoomLevel = 0.2;
          float hoverLevel = exponentialInOut(min(1.0, (distance(vec2(0.5), uv) * hover) + hover));
          uv *= 1.0 - zoomLevel * hoverLevel;
          uv += zoomLevel / 2.0 * hoverLevel;
          uv = clamp(uv, 0.0, 1.0);
          vec4 color = texture2D(uTex, uv);
          if (hoverLevel > 0.0) {
            float h = 1.0 - abs(hoverLevel - 0.5) * 2.0;
            uv.y += color.r * (h * (0.05 + uGlitch * 0.08));
            color = texture2D(uTex, uv);
            float baseShift = h * 0.012;
            float glitchShift = uGlitch * (0.045 + 0.015 * sin(uTime * 2.0));
            float shift = baseShift + glitchShift;
            vec2 shiftVec = vec2(shift, 0.0);
            color.r = texture2D(uTex, uv + shiftVec).r;
            color.g = texture2D(uTex, uv - shiftVec).g;
          }
          vec3 col = color.rgb * uExposure;
          float luma = dot(col, vec3(0.2126, 0.7152, 0.0722));
          col = mix(vec3(luma), col, uSaturation);
          col = mix(col, vec3(1.0), uWash);
          gl_FragColor = vec4(col, 1.0);
        }
      `;
      const material = new THREE.ShaderMaterial({ uniforms, vertexShader, fragmentShader, transparent: false });
      material.toneMapped = true;
      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.NoToneMapping;
      renderer.setClearColor(0xdeefff, 0);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.domElement.style.width = '100%';
      renderer.domElement.style.height = '100%';
      renderer.domElement.style.display = 'block';
      renderer.domElement.style.touchAction = 'none';
      cellEl.appendChild(renderer.domElement);

      let targetHover = 0;
      let currentHover = 0;
      let glitch = 0;
      let disposed = false;
      const target = { scale: 1, posX: 0, rotX: 0, rotY: 0 };

      const onEnter = () => { targetHover = 1; glitch = 0.6; };
      const onLeave = () => {
        targetHover = 0;
        glitch = 0.6;
        target.scale = 1;
        target.posX = 0;
        target.rotX = 0;
        target.rotY = 0;
      };
      const onMove = (e) => {
        const r = cellEl.getBoundingClientRect();
        const mx = ((e.clientX - r.left) / r.width) * 2 - 1;
        const my = -(((e.clientY - r.top) / r.height) * 2 - 1);
        target.scale = Math.max(1.05, 1 - my * 0.08);
        target.posX = mx * 0.4;
        target.rotX = -my * (Math.PI / 3) * 0.3;
        target.rotY = mx * (Math.PI / 3) * 0.3;
      };

      cellEl.style.cursor = 'pointer';
      cellEl.addEventListener('pointerenter', onEnter);
      cellEl.addEventListener('pointerleave', onLeave);
      cellEl.addEventListener('pointermove', onMove);

      return {
        resize(width, height) {
          const w = Math.max(1, Math.floor(width));
          const h = Math.max(1, Math.floor(height));
          renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
          renderer.setSize(w, h, false);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
          uniforms.aspectRatio.value = camera.aspect;
        },
        tick(t) {
          if (disposed) return;
          currentHover += (targetHover - currentHover) * 0.12;
          uniforms.hover.value = currentHover;
          glitch += (0.0 - glitch) * 0.02;
          uniforms.uGlitch.value = glitch;
          uniforms.uTime.value = t;
          const lerp = (a, b, s) => a + (b - a) * s;
          const rotFactor = 1.0 + 0.12 * (Math.abs(mesh.rotation.x) + Math.abs(mesh.rotation.y));
          const targetScaled = target.scale * rotFactor;
          mesh.scale.x = lerp(mesh.scale.x, targetScaled, 0.2);
          mesh.scale.y = lerp(mesh.scale.y, targetScaled, 0.2);
          mesh.position.x = lerp(mesh.position.x, target.posX, 0.2);
          mesh.rotation.x = lerp(mesh.rotation.x, target.rotX, 0.2);
          mesh.rotation.y = lerp(mesh.rotation.y, target.rotY, 0.2);
          renderer.render(scene, camera);
        },
        dispose() {
          if (disposed) return;
          disposed = true;
          cellEl.removeEventListener('pointerenter', onEnter);
          cellEl.removeEventListener('pointerleave', onLeave);
          cellEl.removeEventListener('pointermove', onMove);
          if (renderer.domElement.parentNode) {
            renderer.domElement.parentNode.removeChild(renderer.domElement);
          }
          renderer.dispose();
        }
      };
    }
    function createRapierSwarm(cellEl) {
      if (!cellEl) return null;

      if (!cellEl.style.position) cellEl.style.position = 'relative';

      const container = document.createElement('div');
      container.style.position = 'absolute';
      container.style.inset = '0';
      container.style.background = '#deefff';
      container.style.pointerEvents = 'auto';
      cellEl.appendChild(container);

      const localRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      localRenderer.outputColorSpace = THREE.SRGBColorSpace;
      localRenderer.toneMapping = THREE.NoToneMapping;
      localRenderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      localRenderer.setClearColor(0xdeefff, 1);
      localRenderer.domElement.style.width = '100%';
      localRenderer.domElement.style.height = '100%';
      localRenderer.domElement.style.display = 'block';
      localRenderer.domElement.style.touchAction = 'none';
      container.appendChild(localRenderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xdeefff);
      const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
      camera.position.set(0, 0.9, 4.6);

      const controls = new OrbitControls(camera, localRenderer.domElement);
      controls.enableDamping = false;
      controls.enablePan = false;
      controls.enableRotate = false;
      controls.enableZoom = false;

      const hemi = new THREE.HemisphereLight(0xffffff, 0xc0d6ff, 1.35);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 1.25);
      dir.position.set(3, 4, 5);
      dir.shadow = undefined;
      scene.add(dir);

      const mouse = new THREE.Vector2();
      const mouseWorld = new THREE.Vector3(0, 0.2, 0);
      const raycaster = new THREE.Raycaster();
      const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
      let canvasRect = localRenderer.domElement.getBoundingClientRect();

      const BASE_LIN_DAMP = 2.2;
      const BASE_ANG_DAMP = 1.1;
      const LETTER_SCALE = 4.05;
      const TARGET_CENTER = { x: 0, y: 0.2, z: 0 };
      const RADIAL_GAIN = 1.25;
      const RADIAL_MAX_SPEED = 2.1;
      const RADIAL_BRAKE_OUT = 1.8;
      const TANGENTIAL_GAIN_NEAR = 1.1;
      const TANGENTIAL_GAIN_FAR = 3.2;
      const TANGENTIAL_GAIN_DIST = 3.2;
      const TANGENTIAL_DECAY_FLOOR = 0.05;
      const MAX_DELTA_V = 3.1;
      const MIN_DELTA_V = 0.015;
      const SETTLE_RADIUS = 0.16;
      const SETTLE_SPEED = 0.05;
      const SETTLE_LIN_DAMP = 4.2;
      const SETTLE_ANG_DAMP = 3.6;
      const CENTER_IDLE_RADIUS = 1.6;
      const CENTER_IDLE_WIDTH = 1.4;
      const SEPARATION_RADIUS = 1.68;
      const SEPARATION_PUSH = 0.35;
      const SEPARATION_MAX = 0.9;
      const STEP_DT_MIN = 1 / 240;
      const STEP_DT_MAX = 1 / 30;
      const SPIN_DAMP_THRESHOLD = 0.55;
      const SPIN_LIN_DAMP = 2.8;
      const SPIN_ANG_DAMP = 3.4;
      const COLLIDER_RESTITUTION = 0.8;
      const pointerHalfLength = 1.0;
      const pointerRadius = 0.1; // diameter 0.2 along cylinder axis
      const pointerRestitution = COLLIDER_RESTITUTION * 5;
      const POINTER_REPEL_RADIUS = LETTER_SCALE * 0.85;
      const POINTER_REPEL_PUSH = 2.4;
      const POINTER_REPEL_VEL_GAIN = 1.1;
      const POINTER_VEL_DAMP = 0.6;
      const CLICK_BURST_STRENGTH = 64;
      const CLICK_BURST_SPREAD = 0.35;

      let RAPIER = null;
      let world = null;
      let pointerBody = null;
      const bodies = [];
      const bodyMap = new Map();

      let ready = false;
      let lastTime = null;
      let acc = 0;
      const FIXED = 1 / 60;
      const MAX_STEPS = 3;

      const palette = [0x024b9e, 0x217adf, 0x72b4ff];
      const letterBurstDirections = {
        k: { dir: new THREE.Vector3(-1, 0, 0), strength: 1 },
        e: { dir: new THREE.Vector3(0, 1, 0), strength: 0.65 },
        n: { dir: new THREE.Vector3(1, 0, 0), strength: 1 },
      };

      const pointerState = { x: TARGET_CENTER.x, y: TARGET_CENTER.y, z: TARGET_CENTER.z };
      const pointerVelocity = { x: 0, y: 0, z: 0 };

      let currentWidth = 1;
      let currentHeight = 1;
      let hoverActive = false;

      const syncPointerToMouse = () => {
        const nextX = mouseWorld.x;
        const nextY = mouseWorld.y;
        const nextZ = mouseWorld.z;
        pointerVelocity.x = nextX - pointerState.x;
        pointerVelocity.y = nextY - pointerState.y;
        pointerVelocity.z = nextZ - pointerState.z;
        const stepLenSq = pointerVelocity.x * pointerVelocity.x + pointerVelocity.y * pointerVelocity.y + pointerVelocity.z * pointerVelocity.z;
        const maxStep = POINTER_REPEL_RADIUS * 1.5;
        if (stepLenSq > maxStep * maxStep) {
          const inv = maxStep / Math.sqrt(stepLenSq);
          pointerVelocity.x *= inv;
          pointerVelocity.y *= inv;
          pointerVelocity.z *= inv;
        }
        pointerState.x = nextX;
        pointerState.y = nextY;
        pointerState.z = nextZ;
        if (pointerBody) {
          pointerBody.setTranslation({ x: nextX, y: nextY, z: nextZ }, true);
          pointerBody.setNextKinematicTranslation({ x: nextX, y: nextY, z: nextZ });
          pointerBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
          pointerBody.setAngvel({ x: 0, y: 0, z: 0 }, true);
        }
      };

      const updateMouseWorld = (e) => {
        if (!hoverActive) return;
        canvasRect = localRenderer.domElement.getBoundingClientRect();
        const w = Math.max(canvasRect.width, 1);
        const h = Math.max(canvasRect.height, 1);
        mouse.x = ((e.clientX - canvasRect.left) / w) * 2 - 1;
        mouse.y = -((e.clientY - canvasRect.top) / h) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        raycaster.ray.intersectPlane(plane, mouseWorld);
        mouseWorld.z = TARGET_CENTER.z;
        syncPointerToMouse();
      };

      const resetPointer = () => {
        mouseWorld.set(TARGET_CENTER.x, TARGET_CENTER.y, TARGET_CENTER.z);
        pointerState.x = TARGET_CENTER.x;
        pointerState.y = TARGET_CENTER.y;
        pointerState.z = TARGET_CENTER.z;
        pointerVelocity.x = 0;
        pointerVelocity.y = 0;
        pointerVelocity.z = 0;
        if (pointerBody) {
          pointerBody.setTranslation({ x: TARGET_CENTER.x, y: TARGET_CENTER.y, z: TARGET_CENTER.z }, true);
          pointerBody.setNextKinematicTranslation({ x: TARGET_CENTER.x, y: TARGET_CENTER.y, z: TARGET_CENTER.z });
          pointerBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
          pointerBody.setAngvel({ x: 0, y: 0, z: 0 }, true);
        }
      };

      const setHover = (state, event) => {
        if (state) {
          hoverActive = true;
          if (event) updateMouseWorld(event);
          else syncPointerToMouse();
        } else {
          hoverActive = false;
          resetPointer();
        }
      };

      const handlePointerEnter = (e) => setHover(true, e);
      const handlePointerLeave = () => setHover(false);

      const handleClick = () => {
        if (!ready || !world || bodies.length === 0) return;
        const originX = hoverActive ? pointerState.x : TARGET_CENTER.x;
        const originY = hoverActive ? pointerState.y : TARGET_CENTER.y;
        const originZ = hoverActive ? pointerState.z : TARGET_CENTER.z;
        const jitter = new THREE.Vector3();
        const dir = new THREE.Vector3();
        for (let i = 0; i < bodies.length; i++) {
          const entry = bodies[i];
          const rb = world.getRigidBody(entry.handle);
          if (!rb) continue;
          const pos = rb.translation();
          if (!pos) continue;
          let strengthScale = 1;
          if (entry.key && letterBurstDirections[entry.key]) {
            const spec = letterBurstDirections[entry.key];
            dir.copy(spec.dir).normalize();
            strengthScale = spec.strength ?? 1;
          } else {
            dir.set(pos.x - originX, pos.y - originY, pos.z - originZ);
            const len = dir.length();
            if (len < 1e-3) {
              jitter.randomDirection();
              dir.copy(jitter);
            } else {
              dir.multiplyScalar(1 / len);
            }
          }
          jitter.set((Math.random() - 0.5) * CLICK_BURST_SPREAD, (Math.random() - 0.5) * CLICK_BURST_SPREAD, (Math.random() - 0.5) * CLICK_BURST_SPREAD);
          dir.add(jitter).normalize();
          const massValue = rb.mass?.();
          const mass = Number.isFinite(massValue) && massValue > 0 ? massValue : 1;
          const burst = CLICK_BURST_STRENGTH * strengthScale;
          rb.applyImpulse({ x: dir.x * burst * mass, y: dir.y * burst * mass, z: dir.z * burst * mass }, true);
          pos.free?.();
        }
      };

      localRenderer.domElement.addEventListener('pointerenter', handlePointerEnter, { passive: true });
      localRenderer.domElement.addEventListener('pointermove', updateMouseWorld, { passive: true });
      localRenderer.domElement.addEventListener('pointerleave', handlePointerLeave, { passive: true });
      localRenderer.domElement.addEventListener('pointercancel', handlePointerLeave, { passive: true });
      cellEl.addEventListener('pointerenter', handlePointerEnter, { passive: true });
      cellEl.addEventListener('pointerleave', handlePointerLeave, { passive: true });
      cellEl.addEventListener('click', handleClick);

      const init = async () => {
        try {
          const [rapier, font] = await Promise.all([loadRapier(), getHelvetikerRegular()]);
          RAPIER = rapier;
          world = new RAPIER.World({ x: 0, y: 0, z: 0 });

          const makeTextGeo = (char) => new TextGeometry(char, {
            font,
            size: 0.8,
            depth: 0.28,
            curveSegments: 6,
            bevelEnabled: true,
            bevelThickness: 0.05,
            bevelSize: 0.03,
            bevelSegments: 2
          }).center();

          const geoK = makeTextGeo('k');
          const geoE = makeTextGeo('e');
          const geoN = makeTextGeo('n');

          const geoRadius = (geo) => {
            geo.computeBoundingSphere();
            return Math.max(0.25, geo.boundingSphere?.radius ?? 0.3);
          };

          const radiusK = geoRadius(geoK);
          const radiusE = geoRadius(geoE);
          const radiusN = geoRadius(geoN);

          const pointsFromGeo = (geo) => {
            const src = geo.attributes.position.array;
            if (!src || src.length < 9) return null;
            for (let i = 0; i < src.length; i++) {
              if (!Number.isFinite(src[i])) return null;
            }
            return new Float32Array(src);
          };

          const scalePoints = (points, scale) => {
            if (!points) return null;
            const scaled = new Float32Array(points.length);
            for (let i = 0; i < points.length; i++) scaled[i] = points[i] * scale;
            return scaled;
          };

          const ptsK = pointsFromGeo(geoK);
          const ptsE = pointsFromGeo(geoE);
          const ptsN = pointsFromGeo(geoN);
          const ptsKScaled = scalePoints(ptsK, LETTER_SCALE);
          const ptsEScaled = scalePoints(ptsE, LETTER_SCALE);
          const ptsNScaled = scalePoints(ptsN, LETTER_SCALE);

          const makeHullFresh = (points) => {
            if (!points) return null;
            try {
              return RAPIER.ColliderDesc.convexHull(new Float32Array(points));
            } catch {
              return null;
            }
          };

          const addLetter = (geo, scaledPoints, color, radius, key) => {
            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color, metalness: 0.1, roughness: 0.35 }));
            mesh.position.set((Math.random() - 0.5) * 4, (Math.random() - 0.4) * 2.5, (Math.random() - 0.5) * 3);
            mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            mesh.scale.setScalar(LETTER_SCALE);
            scene.add(mesh);

            const rbDesc = RAPIER.RigidBodyDesc.dynamic()
              .setCanSleep(true)
              .setLinearDamping(BASE_LIN_DAMP)
              .setAngularDamping(BASE_ANG_DAMP)
              .setTranslation(mesh.position.x, mesh.position.y, mesh.position.z);
            const rb = world.createRigidBody(rbDesc);
            rb.setRotation(new RAPIER.Quaternion(mesh.quaternion.x, mesh.quaternion.y, mesh.quaternion.z, mesh.quaternion.w), true);
            const handle = rb.handle;

            mesh.updateMatrixWorld(true);

            const desc = makeHullFresh(scaledPoints);
            if (desc) {
              if (desc.setRestitution) desc.setRestitution(COLLIDER_RESTITUTION);
              world.createCollider(desc, world.getRigidBody(handle));
              desc.free?.();
            } else {
              const size = new THREE.Box3().setFromObject(mesh).getSize(new THREE.Vector3());
              const halfX = Math.max(size.x * 0.5, 0.25 * LETTER_SCALE);
              const halfY = Math.max(size.y * 0.5, 0.25 * LETTER_SCALE);
              const halfZ = Math.max(size.z * 0.5, 0.18 * LETTER_SCALE);
              const fallback = RAPIER.ColliderDesc.cuboid(halfX, halfY, halfZ);
              if (fallback.setRestitution) fallback.setRestitution(COLLIDER_RESTITUTION);
              world.createCollider(fallback, world.getRigidBody(handle));
              fallback.free?.();
            }

            const entryRadius = Number.isFinite(radius) ? radius * LETTER_SCALE : 0.3 * LETTER_SCALE;
            const entry = { mesh, handle, radius: entryRadius, key };
            bodies.push(entry);
            bodyMap.set(handle, entry);
          };

          const count = 3;
          for (let i = 0; i < count; i++) {
            const choice = i % 3;
            const color = palette[Math.min(choice, palette.length - 1)];
            if (choice === 0) addLetter(geoK, ptsKScaled, color, radiusK, 'k');
            else if (choice === 1) addLetter(geoE, ptsEScaled, color, radiusE, 'e');
            else addLetter(geoN, ptsNScaled, color, radiusN, 'n');
          }

          const pointerDesc = RAPIER.RigidBodyDesc.kinematicPositionBased().setCanSleep(false);
          pointerBody = world.createRigidBody(pointerDesc);
          pointerBody.setTranslation({ x: TARGET_CENTER.x, y: TARGET_CENTER.y, z: TARGET_CENTER.z }, true);
          let pointerColliderDesc = RAPIER.ColliderDesc.cylinder(pointerHalfLength, pointerRadius);
          const pointerRotation = new RAPIER.Quaternion(Math.sin(Math.PI / 4), 0, 0, Math.cos(Math.PI / 4));
          if (pointerColliderDesc.setRotation) pointerColliderDesc = pointerColliderDesc.setRotation(pointerRotation);
          if (pointerColliderDesc.setRestitution) pointerColliderDesc = pointerColliderDesc.setRestitution(pointerRestitution);
          world.createCollider(pointerColliderDesc, pointerBody);

          resetPointer();
          ready = true;
        } catch (err) {
          console.error('Rapier swarm initialization failed', err);
        }
      };

      init();

      const applyCenterDrive = (dt) => {
        if (!ready || !world || !pointerBody) return;
        const safeDt = Math.min(Math.max(dt ?? (1 / 60), STEP_DT_MIN), STEP_DT_MAX);
        const distScale = Math.max(TANGENTIAL_GAIN_DIST, 1e-6);

        if (hoverActive) {
          pointerBody.setNextKinematicTranslation({ x: mouseWorld.x, y: mouseWorld.y, z: mouseWorld.z });
        } else {
          pointerBody.setNextKinematicTranslation({ x: TARGET_CENTER.x, y: TARGET_CENTER.y, z: TARGET_CENTER.z });
        }

        const active = [];
        const positions = [];
        const velocities = [];

        for (let i = 0; i < bodies.length; i++) {
          const entry = bodies[i];
          const rb = world.getRigidBody(entry.handle);
          if (!rb) continue;

          const pos = rb.translation();
          const vel = rb.linvel();
          if (!pos || !vel) {
            pos?.free?.();
            vel?.free?.();
            continue;
          }

          const px = pos.x;
          const py = pos.y;
          const pz = pos.z;
          const vx = vel.x;
          const vy = vel.y;
          const vz = vel.z;
          pos.free?.();
          vel.free?.();

          if (!Number.isFinite(px) || !Number.isFinite(py) || !Number.isFinite(pz) || !Number.isFinite(vx) || !Number.isFinite(vy) || !Number.isFinite(vz)) continue;

          const toX = TARGET_CENTER.x - px;
          const toY = TARGET_CENTER.y - py;
          const toZ = TARGET_CENTER.z - pz;
          const distSq = toX * toX + toY * toY + toZ * toZ;
          const dist = Math.sqrt(distSq);
          const speed = Math.hypot(vx, vy, vz);

          if (dist < SETTLE_RADIUS && speed < SETTLE_SPEED) {
            rb.setLinearDamping(SETTLE_LIN_DAMP);
            rb.setAngularDamping(SETTLE_ANG_DAMP);
            rb.setLinvel({ x: 0, y: 0, z: 0 }, true);
            rb.setAngvel({ x: 0, y: 0, z: 0 }, true);
            continue;
          }

          active.push({ entry, rb });
          positions.push({ x: px, y: py, z: pz, toX, toY, toZ, dist });
          velocities.push({ x: vx, y: vy, z: vz });
        }

        if (!active.length) return;

        const sepX = new Array(active.length).fill(0);
        const sepY = new Array(active.length).fill(0);
        const sepZ = new Array(active.length).fill(0);
        const sepRadius2 = SEPARATION_RADIUS * SEPARATION_RADIUS;

        for (let i = 0; i < active.length; i++) {
          const pi = positions[i];
          for (let j = i + 1; j < active.length; j++) {
            const pj = positions[j];
            let dx = pi.x - pj.x;
            let dy = pi.y - pj.y;
            let dz = pi.z - pj.z;
            const dist2 = dx * dx + dy * dy + dz * dz;
            if (dist2 >= sepRadius2 || dist2 <= 1e-9) continue;
            const dist = Math.sqrt(dist2);
            const strength = (SEPARATION_RADIUS - dist) / SEPARATION_RADIUS;
            const push = Math.min(SEPARATION_MAX, strength * SEPARATION_PUSH);
            const inv = push / dist;
            dx *= inv;
            dy *= inv;
            dz *= inv;
            sepX[i] += dx;
            sepY[i] += dy;
            sepZ[i] += dz;
            sepX[j] -= dx;
            sepY[j] -= dy;
            sepZ[j] -= dz;
          }
        }

        if (hoverActive) {
          const pointerPos = pointerBody.translation();
          const ptrX = pointerPos ? pointerPos.x : pointerState.x;
          const ptrY = pointerPos ? pointerPos.y : pointerState.y;
          const ptrZ = pointerPos ? pointerPos.z : pointerState.z;
          const pointerSpeed = Math.hypot(pointerVelocity.x, pointerVelocity.y, pointerVelocity.z);
          const pointerRadiusSq = POINTER_REPEL_RADIUS * POINTER_REPEL_RADIUS;
          for (let i = 0; i < active.length; i++) {
            const pos = positions[i];
            let dx = pos.x - ptrX;
            let dy = pos.y - ptrY;
            let dz = pos.z - ptrZ;
            const distSq = dx * dx + dy * dy + dz * dz;
            if (distSq >= pointerRadiusSq || distSq <= 1e-9) continue;
            const dist = Math.sqrt(distSq);
            const penetration = (POINTER_REPEL_RADIUS - dist) / POINTER_REPEL_RADIUS;
            const basePush = POINTER_REPEL_PUSH * penetration;
            const velPush = pointerSpeed * POINTER_REPEL_VEL_GAIN;
            const push = basePush + velPush;
            const inv = push / dist;
            dx *= inv;
            dy *= inv;
            dz *= inv;
            sepX[i] += dx;
            sepY[i] += dy;
            sepZ[i] += dz;
          }
          pointerPos?.free?.();
        }

        for (let i = 0; i < active.length; i++) {
          const mag = Math.hypot(sepX[i], sepY[i], sepZ[i]);
          if (mag > SEPARATION_MAX) {
            const scale = SEPARATION_MAX / mag;
            sepX[i] *= scale;
            sepY[i] *= scale;
            sepZ[i] *= scale;
          }
        }

        for (let i = 0; i < active.length; i++) {
          const { rb } = active[i];
          const pos = positions[i];
          const vel = velocities[i];

          const dist = pos.dist;
          let dirX = 0;
          let dirY = 0;
          let dirZ = 0;
          if (dist > 1e-8) {
            const invDist = 1 / dist;
            dirX = pos.toX * invDist;
            dirY = pos.toY * invDist;
            dirZ = pos.toZ * invDist;
          }

          const vx = vel.x;
          const vy = vel.y;
          const vz = vel.z;
          const radialSpeed = dirX * vx + dirY * vy + dirZ * vz;
          const tangX = vx - radialSpeed * dirX;
          const tangY = vy - radialSpeed * dirY;
          const tangZ = vz - radialSpeed * dirZ;
          const tangSpeed = Math.hypot(tangX, tangY, tangZ);

          let idleBlend = 1;
          if (dist <= CENTER_IDLE_RADIUS) idleBlend = 0;
          else if (dist < CENTER_IDLE_RADIUS + CENTER_IDLE_WIDTH) {
            idleBlend = (dist - CENTER_IDLE_RADIUS) / CENTER_IDLE_WIDTH;
          }

          let targetRadialBase = Math.min(dist * RADIAL_GAIN, RADIAL_MAX_SPEED) * idleBlend;
          let desiredRadial = targetRadialBase;
          if (radialSpeed < 0) desiredRadial += (-radialSpeed) * RADIAL_BRAKE_OUT;
          desiredRadial = Math.max(desiredRadial, targetRadialBase);

          const distBlend = Math.min(dist / distScale, 1);
          const tangentialGain = TANGENTIAL_GAIN_NEAR + (TANGENTIAL_GAIN_FAR - TANGENTIAL_GAIN_NEAR) * distBlend;
          const tangDecay = Math.max(TANGENTIAL_DECAY_FLOOR, 1 - tangentialGain * safeDt);

          const targetTangX = tangX * tangDecay;
          const targetTangY = tangY * tangDecay;
          const targetTangZ = tangZ * tangDecay;

          const targetVelX = dirX * desiredRadial + targetTangX + sepX[i];
          const targetVelY = dirY * desiredRadial + targetTangY + sepY[i];
          const targetVelZ = dirZ * desiredRadial + targetTangZ + sepZ[i];

          let deltaVelX = targetVelX - vx;
          let deltaVelY = targetVelY - vy;
          let deltaVelZ = targetVelZ - vz;
          const deltaMag = Math.hypot(deltaVelX, deltaVelY, deltaVelZ);
          if (deltaMag > MAX_DELTA_V) {
            const scale = MAX_DELTA_V / deltaMag;
            deltaVelX *= scale;
            deltaVelY *= scale;
            deltaVelZ *= scale;
          }

          const massValue = rb.mass?.();
          const mass = Number.isFinite(massValue) && massValue > 0 ? massValue : 1;

          if (deltaMag < MIN_DELTA_V) {
            if (tangSpeed > SPIN_DAMP_THRESHOLD) {
              rb.setLinearDamping(SPIN_LIN_DAMP);
              rb.setAngularDamping(SPIN_ANG_DAMP);
            } else {
              rb.setLinearDamping(BASE_LIN_DAMP);
              rb.setAngularDamping(BASE_ANG_DAMP);
            }
            continue;
          }

          rb.applyImpulse({ x: deltaVelX * mass, y: deltaVelY * mass, z: deltaVelZ * mass }, true);

          if (tangSpeed > SPIN_DAMP_THRESHOLD) {
            rb.setLinearDamping(SPIN_LIN_DAMP);
            rb.setAngularDamping(SPIN_ANG_DAMP);
          } else {
            rb.setLinearDamping(BASE_LIN_DAMP);
            rb.setAngularDamping(BASE_ANG_DAMP);
          }
        }

        pointerVelocity.x *= POINTER_VEL_DAMP;
        pointerVelocity.y *= POINTER_VEL_DAMP;
        pointerVelocity.z *= POINTER_VEL_DAMP;
      };

      return {
        update(time) {
          if (!ready) return;
          if (lastTime === null) {
            lastTime = time;
            controls.update();
            return;
          }
          const dt = Math.min(0.1, Math.max(0, time - lastTime));
          lastTime = time;

          applyCenterDrive(dt);

          acc += dt;
          let steps = 0;
          while (acc >= FIXED && steps < MAX_STEPS) {
            world.step();
            acc -= FIXED;
            steps++;
          }

          const syncBody = (rb) => {
            const entry = bodyMap.get(rb.handle);
            if (!entry) return;
            const t = rb.translation();
            if (!t) return;
            const tx = t.x;
            const ty = t.y;
            const tz = t.z;
            t.free?.();
            if (!Number.isFinite(tx) || !Number.isFinite(ty) || !Number.isFinite(tz)) return;

            const r = rb.rotation();
            if (r) {
              entry.mesh.quaternion.set(r.x, r.y, r.z, r.w);
              r.free?.();
            }

            entry.mesh.position.set(tx, ty, tz);
          };

          if (world.forEachRigidBody) {
            world.forEachRigidBody(syncBody);
          } else {
            for (let i = 0; i < bodies.length; i++) {
              const rb = world.getRigidBody(bodies[i].handle);
              if (!rb) continue;
              syncBody(rb);
              rb.free?.();
            }
          }

          controls.update();
        },
        render(rect) {
          const w = Math.max(1, Math.floor(rect?.width || 1));
          const h = Math.max(1, Math.floor(rect?.height || 1));
          if (w !== currentWidth || h !== currentHeight) {
            currentWidth = w;
            currentHeight = h;
            localRenderer.setSize(w, h, false);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            canvasRect = localRenderer.domElement.getBoundingClientRect();
          }
          if (!ready) return;
          localRenderer.render(scene, camera);
        },
        _ascii: true
      };
    }
    function createAvatar(cellEl) {
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(30, 1, 0.1, 100);
      camera.position.set(0, 1.5, 1.8);
      camera.lookAt(0, 1.35, 0);
      camera.updateProjectionMatrix();
      scene.add(new THREE.AmbientLight(0xffffff, .8));
      const d = new THREE.DirectionalLight(0xffffff, 1.2);
      d.position.set(2, 3, 4);
      scene.add(d);

      const loader = new GLTFLoader();
      let mixer = null;
      const actions = { waving: null, bow: null };
      let isBowPlaying = false;
      let clickBound = false;

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.NoToneMapping;
      renderer.setClearColor(0xdeefff, 0);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.domElement.style.width = '100%';
      renderer.domElement.style.height = '100%';
      renderer.domElement.style.display = 'block';
      renderer.domElement.style.touchAction = 'none';

      loader.load('./avatar.glb', (gltf) => {
        const root = gltf.scene;
        root.traverse(obj => {
          if (obj.isMesh) {
            obj.castShadow = false;
            obj.receiveShadow = false;
          }
        });
        root.position.set(0, 0, 0);
        scene.add(root);
        if (gltf.animations && gltf.animations.length) {
          mixer = new THREE.AnimationMixer(root);
          const wavingClip = THREE.AnimationClip.findByName(gltf.animations, 'waving-shuto') || gltf.animations[0];
          const bowClip = THREE.AnimationClip.findByName(gltf.animations, 'bow');
          if (wavingClip) {
            actions.waving = mixer.clipAction(wavingClip);
            actions.waving.loop = THREE.LoopRepeat;
            actions.waving.clampWhenFinished = false;
            actions.waving.enabled = true;
            actions.waving.play();
          }
          if (bowClip) {
            actions.bow = mixer.clipAction(bowClip);
            actions.bow.loop = THREE.LoopOnce;
            actions.bow.clampWhenFinished = true;
            actions.bow.enabled = true;
            actions.bow.paused = true; // start paused until triggered
          }

          // click to play bow then return to waving with smooth crossfade
          if (cellEl && !clickBound) {
            clickBound = true;
            const onFinished = (e) => {
              if (!actions.bow || e.action !== actions.bow) return;
              // Crossfade back to waving from the held last frame of bow
              if (actions.waving) {
                actions.waving.reset();
                actions.bow.crossFadeTo(actions.waving, 0.25, true);
                actions.waving.play();
              }
              isBowPlaying = false;
              mixer.removeEventListener('finished', onFinished);
            };
            cellEl.addEventListener('click', () => {
              if (!mixer || isBowPlaying || !actions.bow || !actions.waving) return;
              isBowPlaying = true;
              actions.bow.reset();
              actions.bow.paused = false;
              // Smoothly fade from waving into bow
              actions.waving.crossFadeTo(actions.bow, 0.25, true);
              actions.bow.play();
              mixer.addEventListener('finished', onFinished);
            });
          }
        }
      });

      let lastT = 0;
      if (cellEl && !cellEl.contains(renderer.domElement)) {
        cellEl.appendChild(renderer.domElement);
      }

      let disposed = false;

      return {
        resize(width, height) {
          const w = Math.max(1, Math.floor(width));
          const h = Math.max(1, Math.floor(height));
          renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
          renderer.setSize(w, h, false);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
        },
        tick(t) {
          if (disposed) return;
          const dt = Math.max(0, t - lastT);
          lastT = t;
          if (mixer) mixer.update(dt);
          renderer.render(scene, camera);
        },
        dispose() {
          if (disposed) return;
          disposed = true;
          if (renderer.domElement.parentNode) {
            renderer.domElement.parentNode.removeChild(renderer.domElement);
          }
          renderer.dispose();
        }
      };
    }

    const EFFECTS = {
      number3: createNumber3,
      torus: createTorus,
      particles: createParticles,
      waves: createWaves,
      sphereWire: createSphereWire,
      noiseField: createNumber2,
      avatar: createAvatar,
      image: createImage,
      rapierSwarm: createRapierSwarm,
      halftoneOne: createScanLineOne,
      contactCurtain: createContactCurtain
    };

    const MOBILE_MEDIA = window.matchMedia('(max-width: 900px)');
    const mobileMenuButton = document.querySelector('.mobile-header__menu');
    const mobileDrawer = document.querySelector('.mobile-drawer');
    const mobileDrawerOverlay = mobileDrawer ? mobileDrawer.querySelector('.mobile-drawer__overlay') : null;
    const mobileDrawerLinks = mobileDrawer ? Array.from(mobileDrawer.querySelectorAll('.mobile-drawer__link')) : [];

    function setMobileDrawer(open) {
      if (!mobileDrawer) return;
      const isOpen = document.body.classList.contains('mobile-drawer-open');
      const shouldOpen = typeof open === 'boolean' ? open : !isOpen;
      if (shouldOpen === isOpen) return;
      document.body.classList.toggle('mobile-drawer-open', shouldOpen);
      mobileDrawer.setAttribute('aria-hidden', shouldOpen ? 'false' : 'true');
      if (mobileMenuButton) {
        mobileMenuButton.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
      }
      if (shouldOpen) {
        mobileDrawerLinks[0]?.focus?.();
      } else {
        mobileMenuButton?.focus?.();
      }
    }

    mobileMenuButton?.addEventListener('click', () => setMobileDrawer());
    mobileDrawerOverlay?.addEventListener('click', () => setMobileDrawer(false));
    mobileDrawerLinks.forEach(link => link.addEventListener('click', () => setMobileDrawer(false)));

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && document.body.classList.contains('mobile-drawer-open')) {
        setMobileDrawer(false);
      }
    });

    const handleMobileMediaChange = (event) => {
      if (!event.matches) {
        setMobileDrawer(false);
      }
    };

    if (typeof MOBILE_MEDIA.addEventListener === 'function') {
      MOBILE_MEDIA.addEventListener('change', handleMobileMediaChange);
    } else if (typeof MOBILE_MEDIA.addListener === 'function') {
      MOBILE_MEDIA.addListener(handleMobileMediaChange);
    }

    const DETAIL_TARGET_IDS = ['scene-7', 'scene-8', 'scene-9', 'scene-10', 'scene-11', 'scene-12', 'scene-13', 'scene-14'];
    const DETAIL_TARGET_ID_SET = new Set(DETAIL_TARGET_IDS);
    let svgStrokesHidden = false;
    let svgRestoreTimer = null;

    function hideSvgStrokesReverse(options = {}) {
      const instant = Boolean(options && options.instant);
      if (svgStrokesHidden) return;
      const svg = document.querySelector('.svg-strokes');
      if (!svg) {
        svgStrokesHidden = true;
        return;
      }
      svgStrokesHidden = true;
      if (svgRestoreTimer) {
        clearTimeout(svgRestoreTimer);
        svgRestoreTimer = null;
      }
      if (instant) {
        if (svg.parentNode) svg.remove();
        return;
      }
      const totalTimeline = parseFloat(svg.dataset.strokeTimeline || '0');
      const paths = Array.from(svg.querySelectorAll('path'));
      if (!paths.length) {
        svg.remove();
        return;
      }
      let remaining = paths.length;
      const cleanup = () => {
        if (svg.parentNode) svg.remove();
      };
      paths.forEach((path) => {
        const durationRaw = parseFloat(path.dataset.strokeDuration || '0');
        const delayRaw = parseFloat(path.dataset.strokeDelay || '0');
        const duration = Number.isFinite(durationRaw) ? durationRaw : 0;
        const delay = Number.isFinite(delayRaw) ? delayRaw : 0;
        const endTime = delay + duration;
        const reverseDelayRaw = totalTimeline > 0 ? totalTimeline - endTime : 0;
        const reverseDelay = Number.isFinite(reverseDelayRaw) ? Math.max(reverseDelayRaw, 0) : 0;
        const computedOffsetStr = window.getComputedStyle(path).strokeDashoffset;
        const computedOffset = Number.parseFloat(computedOffsetStr);
        if (Number.isFinite(computedOffset)) {
          path.style.strokeDashoffset = String(computedOffset);
        }
        path.style.animation = 'none';
        void path.getBoundingClientRect();
        const durationValue = Math.max(duration, 0);
        const delayValue = reverseDelay;
        path.style.animation = `draw-stroke ${durationValue}ms ease ${delayValue}ms reverse forwards`;
        if (durationValue === 0) {
          remaining -= 1;
          if (remaining === 0) cleanup();
          return;
        }
        path.addEventListener('animationend', () => {
          remaining -= 1;
          if (remaining === 0) cleanup();
        }, { once: true });
      });
    }

    function scheduleRestoreSvgStrokes(delay = 0) {
      if (!svgStrokesHidden) return;
      if (svgRestoreTimer) {
        clearTimeout(svgRestoreTimer);
      }
      svgRestoreTimer = window.setTimeout(() => {
        svgRestoreTimer = null;
        svgStrokesHidden = false;
        buildGridStrokes({ force: true });
      }, Math.max(0, delay));
    }

    // ===== attach to cells =====
    const sceneCells = Array.from(document.querySelectorAll('.scene'));
    const gridEl = document.querySelector('.grid5x3');
    const infoPanel = document.getElementById('scene-6');
    const INFO_PANEL_HIDDEN_CLASS = 'scene-info--hidden';

    class CellEffectController {
      constructor(cell, factory) {
        this.cell = cell;
        this.factory = factory;
        this.effect = null;
        this.resizeObserver = null;
        this.resizeCleanup = null;
        this.isActive = false;
        this.rafId = null;
        this.wasActiveBeforeScroll = false;
      }

      ensureEffect() {
        if (this.effect) return;
        try {
          this.effect = this.factory(this.cell);
        } catch (error) {
          console.error('Failed to create effect for cell', this.cell, error);
          this.effect = null;
          return;
        }
        if (!this.effect) return;

        if (typeof this.effect.resize === 'function') {
          const applySize = () => {
            const rect = this.cell.getBoundingClientRect();
            if (rect.width && rect.height) {
              this.effect.resize(rect.width, rect.height);
            }
          };
          if (typeof ResizeObserver === 'function') {
            this.resizeObserver = new ResizeObserver((entries) => {
              for (const entry of entries) {
                const rect = entry.contentRect;
                const width = rect?.width ?? rect?.inlineSize;
                const height = rect?.height ?? rect?.blockSize;
                if (width && height && typeof this.effect.resize === 'function') {
                  this.effect.resize(width, height);
                }
              }
            });
            this.resizeObserver.observe(this.cell);
          } else {
            window.addEventListener('resize', applySize);
            this.resizeCleanup = () => window.removeEventListener('resize', applySize);
          }
          applySize();
        }

        if (typeof this.effect.start === 'function') {
          this.effect.start();
        }
      }

      prime(timestampMs) {
        this.ensureEffect();
        if (!this.effect) return;
        const timeMs = typeof timestampMs === 'number' ? timestampMs : performance.now();
        const timeSeconds = timeMs / 1000;
        if (typeof this.effect.tick === 'function') {
          this.effect.tick(timeSeconds);
        } else {
          this.effect.update?.(timeSeconds);
        }
        if (typeof this.effect.render === 'function') {
          const rect = this.cell.getBoundingClientRect();
          this.effect.render(rect);
        }
      }

      start() {
        this.ensureEffect();
        if (!this.effect || this.isActive) return;
        this.isActive = true;
        if (typeof this.effect.resume === 'function') {
          this.effect.resume();
        }
        this.prime(performance.now());
        this.rafId = requestAnimationFrame(this.loop);
      }

      loop = (timestamp) => {
        if (!this.isActive) return;
        const time = timestamp / 1000;
        if (typeof this.effect.tick === 'function') {
          this.effect.tick(time);
        } else {
          this.effect.update?.(time);
          if (typeof this.effect.render === 'function') {
            const rect = this.cell.getBoundingClientRect();
            this.effect.render(rect);
          }
        }
        this.rafId = requestAnimationFrame(this.loop);
      };

      stop({ fromScroll = false } = {}) {
        if (!this.isActive) return;
        this.isActive = false;
        if (this.rafId !== null) {
          cancelAnimationFrame(this.rafId);
          this.rafId = null;
        }
        if (fromScroll) {
          if (typeof this.effect?.pause === 'function') {
            this.effect.pause();
          }
        } else if (typeof this.effect?.stop === 'function') {
          this.effect.stop();
        }
      }

      pauseForScroll() {
        // no-op to keep effects running during scroll interactions
      }

      resumeAfterScroll() {
        if (this.wasActiveBeforeScroll) {
          this.wasActiveBeforeScroll = false;
          this.start();
        }
      }

      dispose() {
        this.stop();
        this.resizeObserver?.disconnect();
        this.resizeCleanup?.();
        this.effect?.dispose?.();
        this.effect = null;
      }
    }

    const effectControllers = new Map();
    const effectObserver = new IntersectionObserver((entries) => {
      for (const entry of entries) {
        const controller = effectControllers.get(entry.target);
        if (!controller) continue;
        if (entry.isIntersecting) {
          controller.start();
        } else {
          controller.stop();
        }
      }
    }, { threshold: 0.2 });

    sceneCells.forEach((cell) => {
      const type = cell.dataset.effect;
      const factory = EFFECTS[type];
      if (!factory) return;
      const controller = new CellEffectController(cell, factory);
      effectControllers.set(cell, controller);
      effectObserver.observe(cell);
    });

    function computeIntersectionRatio(rect, viewportWidth, viewportHeight) {
      if (!rect || rect.width <= 0 || rect.height <= 0 || viewportWidth <= 0 || viewportHeight <= 0) {
        return 0;
      }
      const intersectWidth = Math.max(0, Math.min(rect.right, viewportWidth) - Math.max(rect.left, 0));
      const intersectHeight = Math.max(0, Math.min(rect.bottom, viewportHeight) - Math.max(rect.top, 0));
      const intersectArea = intersectWidth * intersectHeight;
      if (intersectArea <= 0) return 0;
      const totalArea = rect.width * rect.height;
      if (totalArea <= 0) return 0;
      return intersectArea / totalArea;
    }

    function scheduleIdleWork(cb) {
      if (typeof window.requestIdleCallback === 'function') {
        window.requestIdleCallback(cb, { timeout: 500 });
      } else {
        window.setTimeout(cb, 16);
      }
    }

    const INITIAL_VISIBILITY_THRESHOLD = 0.2;
    const viewportWidth = window.innerWidth || document.documentElement.clientWidth || 0;
    const viewportHeight = window.innerHeight || document.documentElement.clientHeight || 0;
    const controllersList = Array.from(effectControllers.values());
    const visibilityEntries = controllersList.map((controller) => {
      const rect = controller.cell.getBoundingClientRect();
      const ratio = computeIntersectionRatio(rect, viewportWidth, viewportHeight);
      return { controller, ratio };
    });

    const initiallyVisible = visibilityEntries
      .filter(entry => entry.ratio >= INITIAL_VISIBILITY_THRESHOLD)
      .sort((a, b) => b.ratio - a.ratio);
    const initiallyHidden = visibilityEntries
      .filter(entry => entry.ratio < INITIAL_VISIBILITY_THRESHOLD)
      .sort((a, b) => b.ratio - a.ratio);

    if (initiallyVisible.length) {
      window.requestAnimationFrame(() => {
        initiallyVisible.forEach(({ controller }) => controller.start());
      });
    }

    if (initiallyHidden.length) {
      const warmupQueue = initiallyHidden.map(entry => entry.controller);
      const warmupNext = () => {
        if (!warmupQueue.length) return;
        const controller = warmupQueue.shift();
        controller.ensureEffect();
        window.requestAnimationFrame((timestamp) => controller.prime(timestamp));
        if (warmupQueue.length) {
          scheduleIdleWork(warmupNext);
        }
      };
      const launchWarmup = () => scheduleIdleWork(warmupNext);
      if (initiallyVisible.length) {
        window.requestAnimationFrame(() => {
          window.requestAnimationFrame(launchWarmup);
        });
      } else {
        window.requestAnimationFrame(launchWarmup);
      }
    }

    let scrollResumeTimer = null;
    const SCROLL_RESUME_DELAY = 160;
    const pauseEffectsForScroll = () => {
      effectControllers.forEach((controller) => controller.pauseForScroll());
    };
    const scheduleScrollResume = () => {
      if (scrollResumeTimer) window.clearTimeout(scrollResumeTimer);
      scrollResumeTimer = window.setTimeout(() => {
        effectControllers.forEach((controller) => controller.resumeAfterScroll());
      }, SCROLL_RESUME_DELAY);
    };

    window.addEventListener('scroll', () => {
      pauseEffectsForScroll();
      scheduleScrollResume();
    }, { passive: true });

    window.addEventListener('touchmove', () => {
      pauseEffectsForScroll();
      scheduleScrollResume();
    }, { passive: true });

    window.addEventListener('touchend', scheduleScrollResume, { passive: true });

    // ===== simple grid column focuser =====
    (function setupColumnFocus() {
      if (!gridEl) return;
      const articles = Array.from(gridEl.querySelectorAll('article')).filter(cell => DETAIL_TARGET_ID_SET.has(cell.id));
      if (!articles.length) return;

      const initialViewportWidth = window.innerWidth || document.documentElement.clientWidth || 0;
      const initialViewportHeight = window.innerHeight || document.documentElement.clientHeight || 0;

      const focusAnimation = {
        duration: 1000,
        frame: null,
        scrollFrame: null,
        sequenceTimer: null,
        baseColumnOffsets: [],
        baseRowOffsets: [],
        baseColumns: [],
        baseRows: [],
        columnsCurrent: [],
        rowsCurrent: [],
        columnGap: 0,
        rowGap: 0,
        autoRowsInline: '',
        autoRowsComputed: '',
        cellTrackInfo: new Map(),
        viewportWidth: initialViewportWidth,
        viewportHeight: initialViewportHeight
      };
      const POSITION_EPSILON = 1.5;
      let expandedArticle = null;

      let expandedColumn = -1;
      let expandedRow = -1;

      const easeInOutCubic = (t) => (t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2);

      function clampIndex(value, count) {
        if (!Number.isFinite(value)) return -1;
        if (count <= 0) return -1;
        const intValue = Math.floor(value);
        if (intValue < 0) return 0;
        if (intValue >= count) return count - 1;
        return intValue;
      }

      function resolveGridLineIndex(rawValue, count) {
        if (!rawValue) return -1;
        const parsed = Number.parseInt(rawValue, 10);
        if (!Number.isFinite(parsed)) return -1;
        return clampIndex(parsed - 1, count);
      }

      function parseSpanToken(value) {
        if (!value) return 0;
        const match = value.trim().match(/^span\s+(\d+)$/i);
        if (!match) return 0;
        const parsed = Number.parseInt(match[1], 10);
        return Number.isFinite(parsed) && parsed > 0 ? parsed : 0;
      }

      function resolveGridSpan(startValue, endValue) {
        const spanToken = parseSpanToken(endValue);
        if (spanToken > 0) return spanToken;
        const start = Number.parseInt(startValue, 10);
        const end = Number.parseInt(endValue, 10);
        if (Number.isFinite(start) && Number.isFinite(end)) {
          return Math.max(1, end - start);
        }
        return 1;
      }

      function getClosestIndex(offsets, offsetValue) {
        if (!offsets.length) return -1;
        let closest = 0;
        let minDiff = Infinity;
        offsets.forEach((offset, idx) => {
          const diff = Math.abs(offset - offsetValue);
          if (diff < minDiff) {
            minDiff = diff;
            closest = idx;
          }
        });
        return closest;
      }

      function getColumnIndexByOffset(cell) {
        const offsets = focusAnimation.baseColumnOffsets;
        if (!offsets.length) return -1;
        const gridRect = gridEl.getBoundingClientRect();
        const rect = cell.getBoundingClientRect();
        const cellOffset = rect.left - gridRect.left;
        return getClosestIndex(offsets, cellOffset);
      }

      function getRowIndexByOffset(cell) {
        const offsets = focusAnimation.baseRowOffsets;
        if (!offsets.length) return -1;
        const gridRect = gridEl.getBoundingClientRect();
        const rect = cell.getBoundingClientRect();
        const cellOffset = rect.top - gridRect.top;
        return getClosestIndex(offsets, cellOffset);
      }

      function updateCellTrackInfo() {
        const infoMap = focusAnimation.cellTrackInfo;
        infoMap.clear();
        const columnCount = focusAnimation.baseColumns.length;
        const rowCount = focusAnimation.baseRows.length;
        const gridRect = gridEl.getBoundingClientRect();
        const gridLeft = gridRect.left;
        const gridTop = gridRect.top;

        articles.forEach(cell => {
          const rect = cell.getBoundingClientRect();
          const style = window.getComputedStyle(cell);
          let columnIndex = resolveGridLineIndex(style.gridColumnStart, columnCount);
          let rowIndex = resolveGridLineIndex(style.gridRowStart, rowCount);
          let columnSpan = resolveGridSpan(style.gridColumnStart, style.gridColumnEnd);
          let rowSpan = resolveGridSpan(style.gridRowStart, style.gridRowEnd);

          if (columnIndex === -1) {
            columnIndex = getClosestIndex(focusAnimation.baseColumnOffsets, rect.left - gridLeft);
          }
          if (rowIndex === -1) {
            rowIndex = getClosestIndex(focusAnimation.baseRowOffsets, rect.top - gridTop);
          }

          if (columnIndex >= 0 && columnCount > 0) {
            columnIndex = clampIndex(columnIndex, columnCount);
            const remainingColumns = Math.max(1, columnCount - columnIndex);
            columnSpan = Math.min(Math.max(1, columnSpan), remainingColumns);
          } else {
            columnSpan = Math.max(1, columnSpan);
          }

          if (rowIndex >= 0 && rowCount > 0) {
            rowIndex = clampIndex(rowIndex, rowCount);
            const remainingRows = Math.max(1, rowCount - rowIndex);
            rowSpan = Math.min(Math.max(1, rowSpan), remainingRows);
          } else {
            rowSpan = Math.max(1, rowSpan);
          }

          infoMap.set(cell, {
            columnIndex,
            rowIndex,
            columnSpan,
            rowSpan
          });
        });
      }

      function getTrackCount(property) {
        const value = window.getComputedStyle(gridEl)[property];
        if (!value) return 0;
        const trimmed = value.trim();
        if (!trimmed) return 0;
        const repeatMatch = trimmed.match(/^repeat\(\s*(\d+)\s*,/i);
        if (repeatMatch) return parseInt(repeatMatch[1], 10) || 0;
        return trimmed.split(/\s+/).filter(Boolean).length;
      }

      function measureBaseState() {
        const previousColumnStyle = gridEl.style.gridTemplateColumns;
        const previousRowStyle = gridEl.style.gridTemplateRows;
        if (expandedColumn !== -1 || expandedRow !== -1) {
          gridEl.style.removeProperty('grid-template-columns');
          gridEl.style.removeProperty('grid-template-rows');
        }

        const style = window.getComputedStyle(gridEl);
        focusAnimation.columnGap = parseFloat(style.columnGap || '0') || 0;
        focusAnimation.rowGap = parseFloat(style.rowGap || '0') || 0;
        focusAnimation.autoRowsInline = gridEl.style.gridAutoRows || '';
        focusAnimation.autoRowsComputed = style.gridAutoRows || '';

        const gridRect = gridEl.getBoundingClientRect();
        const columnPositions = [];
        const rowPositions = [];

        const cells = Array.from(gridEl.querySelectorAll('.cell'));
        cells.forEach(cell => {
          const rect = cell.getBoundingClientRect();
          if (!rect) return;
          const left = rect.left;
          const top = rect.top;
          if (!columnPositions.some(pos => Math.abs(pos - left) <= POSITION_EPSILON)) {
            columnPositions.push(left);
          }
          if (!rowPositions.some(pos => Math.abs(pos - top) <= POSITION_EPSILON)) {
            rowPositions.push(top);
          }
        });

        columnPositions.sort((a, b) => a - b);
        rowPositions.sort((a, b) => a - b);

        const inferredColumnCount = Math.max(getTrackCount('gridTemplateColumns'), columnPositions.length, 1);
        const inferredRowCount = Math.max(getTrackCount('gridTemplateRows'), rowPositions.length, 1);

        if (!columnPositions.length) {
          const width = Math.max(0, (gridRect.width - focusAnimation.columnGap * Math.max(inferredColumnCount - 1, 0)) / inferredColumnCount);
          for (let i = 0; i < inferredColumnCount; i++) {
            columnPositions.push(gridRect.left + i * (width + focusAnimation.columnGap));
          }
        }

        if (!rowPositions.length) {
          const height = Math.max(0, (gridRect.height - focusAnimation.rowGap * Math.max(inferredRowCount - 1, 0)) / inferredRowCount);
          for (let i = 0; i < inferredRowCount; i++) {
            rowPositions.push(gridRect.top + i * (height + focusAnimation.rowGap));
          }
        }

        const columnOffsets = columnPositions.map(pos => pos - gridRect.left);
        const rowOffsets = rowPositions.map(pos => pos - gridRect.top);
        const columnWidths = columnPositions.map((pos, idx) => {
          const next = idx < columnPositions.length - 1 ? columnPositions[idx + 1] : gridRect.right;
          return Math.max(0, next - pos);
        });
        const rowHeights = rowPositions.map((pos, idx) => {
          const next = idx < rowPositions.length - 1 ? rowPositions[idx + 1] : gridRect.bottom;
          return Math.max(0, next - pos);
        });

        focusAnimation.baseColumnOffsets = columnOffsets;
        focusAnimation.baseColumns = columnWidths;
        focusAnimation.baseRowOffsets = rowOffsets;
        focusAnimation.baseRows = rowHeights;
        focusAnimation.columnsCurrent = columnWidths.slice();
        focusAnimation.rowsCurrent = rowHeights.slice();
        updateCellTrackInfo();
        focusAnimation.viewportWidth = window.innerWidth || document.documentElement.clientWidth || gridRect.width;
        focusAnimation.viewportHeight = window.innerHeight || document.documentElement.clientHeight || gridRect.height;

        if (expandedColumn !== -1 || expandedRow !== -1) {
          gridEl.style.gridTemplateColumns = previousColumnStyle;
          gridEl.style.gridTemplateRows = previousRowStyle;
        }
      }

      function startAnimation(columnsTarget, rowsTarget, options = {}) {
        const columnCount = focusAnimation.baseColumns.length;
        const rowCount = focusAnimation.baseRows.length;
        if (columnCount === 0 || rowCount === 0) return;

        const startColumns = focusAnimation.columnsCurrent.length === columnCount
          ? focusAnimation.columnsCurrent.slice()
          : focusAnimation.baseColumns.slice();
        const startRows = focusAnimation.rowsCurrent.length === rowCount
          ? focusAnimation.rowsCurrent.slice()
          : focusAnimation.baseRows.slice();

        const targetColumns = columnsTarget.slice(0, columnCount);
        while (targetColumns.length < columnCount) targetColumns.push(0);

        const targetRows = rowsTarget.slice(0, rowCount);
        while (targetRows.length < rowCount) targetRows.push(0);

        if (focusAnimation.frame) cancelAnimationFrame(focusAnimation.frame);
        if (focusAnimation.sequenceTimer) {
          clearTimeout(focusAnimation.sequenceTimer);
          focusAnimation.sequenceTimer = null;
        }

        const applyFrame = (columns, rows) => {
          const normalizedColumns = [];
          const normalizedRows = [];
          for (let i = 0; i < columnCount; i += 1) {
            normalizedColumns.push(Math.max(columns[i] ?? 0, 0));
          }
          for (let i = 0; i < rowCount; i += 1) {
            normalizedRows.push(Math.max(rows[i] ?? 0, 0));
          }
          gridEl.style.gridTemplateColumns = normalizedColumns.map(v => `${v}px`).join(' ');
          gridEl.style.gridTemplateRows = normalizedRows.map(v => `${v}px`).join(' ');
          focusAnimation.columnsCurrent = normalizedColumns;
          focusAnimation.rowsCurrent = normalizedRows;
        };

        if (options.sequence === 'row-then-column') {
          const EPSILON = 0.5;
          const hasRowChange = targetRows.some((value, idx) => Math.abs(value - (startRows[idx] ?? 0)) > EPSILON);
          const hasColumnChange = targetColumns.some((value, idx) => Math.abs(value - (startColumns[idx] ?? 0)) > EPSILON);

          const rowPhaseRatio = typeof options.rowPhaseRatio === 'number' ? options.rowPhaseRatio : 0.6;
          const clampedRowRatio = Math.min(Math.max(rowPhaseRatio, 0), 1);
          const rowDuration = Math.max(1, Math.round(typeof options.rowDuration === 'number'
            ? options.rowDuration
            : focusAnimation.duration * clampedRowRatio));
          const defaultColumnDuration = Math.max(focusAnimation.duration - rowDuration, Math.round(focusAnimation.duration * 0.4));
          const columnDuration = Math.max(1, Math.round(typeof options.columnDuration === 'number'
            ? options.columnDuration
            : defaultColumnDuration));
          const phaseDelay = typeof options.phaseDelay === 'number' ? options.phaseDelay : 140;

          const startColumnAnimation = () => {
            focusAnimation.sequenceTimer = null;
            if (!hasColumnChange) {
              applyFrame(targetColumns, targetRows);
              options.onComplete?.();
              return;
            }
            const columnStart = focusAnimation.columnsCurrent.length === columnCount
              ? focusAnimation.columnsCurrent.slice()
              : startColumns.slice();
            const columnStartTime = performance.now();
            const stepColumn = (now) => {
              const progress = Math.min(1, (now - columnStartTime) / columnDuration);
              const eased = easeInOutCubic(progress);
              const columns = columnStart.map((start, idx) => start + (targetColumns[idx] - start) * eased);
              applyFrame(columns, targetRows);
              if (progress < 1) {
                focusAnimation.frame = requestAnimationFrame(stepColumn);
              } else {
                focusAnimation.frame = null;
                options.onComplete?.();
              }
            };
            focusAnimation.frame = requestAnimationFrame(stepColumn);
          };

          const launchColumn = () => {
            if (phaseDelay > 0 && hasColumnChange) {
              focusAnimation.sequenceTimer = window.setTimeout(startColumnAnimation, phaseDelay);
            } else {
              startColumnAnimation();
            }
          };

          if (!hasRowChange) {
            applyFrame(startColumns, targetRows);
            launchColumn();
            return;
          }

          const rowStartTime = performance.now();
          const stepRow = (now) => {
            const progress = Math.min(1, (now - rowStartTime) / rowDuration);
            const eased = easeInOutCubic(progress);
            const rows = startRows.map((start, idx) => start + (targetRows[idx] - start) * eased);
            applyFrame(startColumns, rows);
            if (progress < 1) {
              focusAnimation.frame = requestAnimationFrame(stepRow);
            } else {
              focusAnimation.frame = null;
              applyFrame(startColumns, targetRows);
              launchColumn();
            }
          };

          focusAnimation.frame = requestAnimationFrame(stepRow);
          return;
        }

        const startTime = performance.now();
        const step = (now) => {
          const progress = Math.min(1, (now - startTime) / focusAnimation.duration);
          const eased = easeInOutCubic(progress);
          const columns = startColumns.map((start, idx) => start + (targetColumns[idx] - start) * eased);
          const rows = startRows.map((start, idx) => start + (targetRows[idx] - start) * eased);
          applyFrame(columns, rows);
          if (progress < 1) {
            focusAnimation.frame = requestAnimationFrame(step);
          } else {
            focusAnimation.frame = null;
            options.onComplete?.();
          }
        };

        focusAnimation.frame = requestAnimationFrame(step);
      }

      function startScrollAnimation(targetY) {
        if (focusAnimation.scrollFrame) {
          cancelAnimationFrame(focusAnimation.scrollFrame);
          focusAnimation.scrollFrame = null;
        }
        const startY = window.scrollY || window.pageYOffset || 0;
        const delta = targetY - startY;
        if (Math.abs(delta) < 1) return;
        const startTime = performance.now();
        function step(now) {
          const progress = Math.min(1, (now - startTime) / focusAnimation.duration);
          const eased = easeInOutCubic(progress);
          window.scrollTo(0, startY + delta * eased);
          if (progress < 1) {
            focusAnimation.scrollFrame = requestAnimationFrame(step);
          } else {
            focusAnimation.scrollFrame = null;
          }
        }
        focusAnimation.scrollFrame = requestAnimationFrame(step);
      }

      function getColumnIndexForCell(cell) {
        const info = focusAnimation.cellTrackInfo.get(cell);
        if (info && info.columnIndex >= 0) return info.columnIndex;
        return getColumnIndexByOffset(cell);
      }

      function getRowIndexForCell(cell) {
        const info = focusAnimation.cellTrackInfo.get(cell);
        if (info && info.rowIndex >= 0) return info.rowIndex;
        return getRowIndexByOffset(cell);
      }

      function ensureDetailContent(cell) {
        if (!cell || cell.querySelector('.scene__detail-overlay')) return;
        const title = cell.dataset.title || '';
        const description = cell.dataset.description || '';
        const link = cell.dataset.link || '';
        const linkLabel = cell.dataset.linkLabel || 'Open link';

        const overlay = document.createElement('div');
        overlay.className = 'scene__detail-overlay';
        overlay.addEventListener('click', (event) => event.stopPropagation());

        const body = document.createElement('div');
        body.className = 'scene__detail-body';
        if (title) {
          const heading = document.createElement('h3');
          heading.className = 'scene__detail-title';
          heading.textContent = title;
          body.appendChild(heading);
        }
        if (description) {
          const paragraph = document.createElement('div');
          paragraph.className = 'scene__detail-text';
          const normalized = description.replace(/\r\n?/g, '\n');
          if (/<[a-z][\s\S]*>/i.test(normalized)) {
            paragraph.innerHTML = normalized;
          } else {
            const parts = normalized.split(/\n+/).map(part => part.trim()).filter(Boolean);
            parts.forEach((part, index) => {
              if (index > 0) paragraph.appendChild(document.createElement('br'));
              paragraph.appendChild(document.createTextNode(part));
            });
          }
          body.appendChild(paragraph);
        }

        const actions = document.createElement('div');
        actions.className = 'scene__detail-actions';
        if (link) {
          const anchor = document.createElement('a');
          anchor.className = 'scene__detail-link';
          anchor.href = link;
          anchor.target = '_blank';
          anchor.rel = 'noopener noreferrer';
          anchor.textContent = linkLabel;
          actions.appendChild(anchor);
        }
        const closeBtn = document.createElement('button');
        closeBtn.type = 'button';
        closeBtn.className = 'scene__detail-close';
        closeBtn.setAttribute('aria-label', 'Close detail');
        closeBtn.textContent = 'Close';
        closeBtn.addEventListener('click', (event) => {
          event.stopPropagation();
          resetFocus();
        });
        actions.appendChild(closeBtn);
        body.appendChild(actions);
        overlay.appendChild(body);
        cell.appendChild(overlay);
      }

      function lockGridToCurrentSize() {
        const { baseColumns, baseRows, columnsCurrent, rowsCurrent } = focusAnimation;
        const columns = columnsCurrent.length === baseColumns.length && columnsCurrent.length
          ? columnsCurrent
          : baseColumns;
        const rows = rowsCurrent.length === baseRows.length && rowsCurrent.length
          ? rowsCurrent
          : baseRows;
        if (columns.length) {
          const list = columns.map(value => `${Math.max(value, 0)}px`).join(' ');
          gridEl.style.gridTemplateColumns = list;
          focusAnimation.columnsCurrent = columns.slice();
        }
        if (rows.length) {
          const list = rows.map(value => `${Math.max(value, 0)}px`).join(' ');
          gridEl.style.gridTemplateRows = list;
          focusAnimation.rowsCurrent = rows.slice();
        }
      }

      function openDetail(cell) {
        if (!cell) return;
        ensureDetailContent(cell);
        if (expandedArticle && expandedArticle !== cell) {
          expandedArticle.classList.remove('scene--detail-open');
        }
        if (!focusAnimation.baseColumns.length || !focusAnimation.baseRows.length) {
          measureBaseState();
        }
        lockGridToCurrentSize();
        expandedArticle = cell;
        cell.classList.add('scene--detail-open');
        document.body.classList.add('scene-overlay-open');
        if (infoPanel) {
          infoPanel.classList.add(INFO_PANEL_HIDDEN_CLASS);
          infoPanel.setAttribute('aria-hidden', 'true');
        }
        if (DETAIL_TARGET_ID_SET.has(cell.id)) {
          hideSvgStrokesReverse();
        }
      }

      function closeDetail() {
        if (!expandedArticle) return;
        expandedArticle.classList.remove('scene--detail-open');
        expandedArticle = null;
        document.body.classList.remove('scene-overlay-open');
        if (infoPanel) {
          infoPanel.classList.remove(INFO_PANEL_HIDDEN_CLASS);
          infoPanel.removeAttribute('aria-hidden');
        }
      }

      function applyFocus(cell, columnIndex, rowIndex) {
        const columnCount = focusAnimation.baseColumns.length;
        const rowCount = focusAnimation.baseRows.length;
        if (columnCount === 0 || rowCount === 0) return;
        if (columnIndex < 0 || columnIndex >= columnCount) return;
        if (rowIndex < 0 || rowIndex >= rowCount) return;

        const trackInfo = focusAnimation.cellTrackInfo.get(cell) || null;
        const columnSpanRaw = trackInfo?.columnSpan ?? 1;
        const rowSpanRaw = trackInfo?.rowSpan ?? 1;
        const columnSpan = Math.max(1, Math.min(columnSpanRaw, columnCount - columnIndex));
        const rowSpan = Math.max(1, Math.min(rowSpanRaw, rowCount - rowIndex));

        gridEl.style.gridAutoRows = '0px';

        const gridRect = gridEl.getBoundingClientRect();
        const totalColumnWidth = gridRect.width;
        const columnsTarget = focusAnimation.baseColumns.map(() => 0);
        for (let i = 0; i < columnSpan; i += 1) {
          const idx = Math.min(columnCount - 1, columnIndex + i);
          columnsTarget[idx] = totalColumnWidth / columnSpan;
        }

        const baseSpanHeight = focusAnimation.baseRows.slice(rowIndex, rowIndex + rowSpan).reduce((sum, value) => sum + value, 0);
        const rowGapAllowance = focusAnimation.rowGap * Math.max(rowSpan - 1, 0);
        const targetRowHeightTotal = Math.max(0, window.innerHeight - rowGapAllowance, baseSpanHeight);
        const rowsTarget = focusAnimation.baseRows.map(() => 0);
        if (baseSpanHeight > 0) {
          for (let i = 0; i < rowSpan; i += 1) {
            const idx = Math.min(rowCount - 1, rowIndex + i);
            const baseHeight = focusAnimation.baseRows[idx] || 0;
            const weight = baseHeight / baseSpanHeight;
            rowsTarget[idx] = targetRowHeightTotal * weight;
          }
        } else {
          const fallbackShare = rowSpan > 0 ? targetRowHeightTotal / rowSpan : targetRowHeightTotal;
          for (let i = 0; i < rowSpan; i += 1) {
            const idx = Math.min(rowCount - 1, rowIndex + i);
            rowsTarget[idx] = fallbackShare;
          }
        }

        expandedColumn = columnIndex;
        expandedRow = rowIndex;
        startAnimation(columnsTarget, rowsTarget, { sequence: 'row-then-column' });
        const rowOffset = focusAnimation.baseRowOffsets[rowIndex] ?? 0;
        const targetScrollY = Math.max(0, (window.scrollY || window.pageYOffset || 0) + gridRect.top + rowOffset);
        startScrollAnimation(targetScrollY);
      }

      function resetFocus(immediate = false) {
        if (focusAnimation.frame) {
          cancelAnimationFrame(focusAnimation.frame);
          focusAnimation.frame = null;
        }
        if (focusAnimation.scrollFrame) {
          cancelAnimationFrame(focusAnimation.scrollFrame);
          focusAnimation.scrollFrame = null;
        }
        if (focusAnimation.sequenceTimer) {
          clearTimeout(focusAnimation.sequenceTimer);
          focusAnimation.sequenceTimer = null;
        }
        closeDetail();
        expandedColumn = -1;
        expandedRow = -1;

        const autoRowsValue = focusAnimation.autoRowsInline || focusAnimation.autoRowsComputed || '';
        if (autoRowsValue) {
          gridEl.style.gridAutoRows = autoRowsValue;
        } else {
          gridEl.style.removeProperty('grid-auto-rows');
        }

        if (immediate || !focusAnimation.baseColumns.length || !focusAnimation.baseRows.length) {
          gridEl.style.removeProperty('grid-template-columns');
          gridEl.style.removeProperty('grid-template-rows');
          focusAnimation.columnsCurrent = focusAnimation.baseColumns.slice();
          focusAnimation.rowsCurrent = focusAnimation.baseRows.slice();
        } else {
          startAnimation(focusAnimation.baseColumns.slice(), focusAnimation.baseRows.slice(), {
            onComplete: () => {
              gridEl.style.removeProperty('grid-template-columns');
              gridEl.style.removeProperty('grid-template-rows');
              focusAnimation.columnsCurrent = focusAnimation.baseColumns.slice();
              focusAnimation.rowsCurrent = focusAnimation.baseRows.slice();
            }
          });
        }
        if (svgStrokesHidden) {
          const delay = immediate ? 0 : focusAnimation.duration + 60;
          scheduleRestoreSvgStrokes(delay);
        }
      }

      articles.forEach(cell => {
        cell.style.cursor = 'pointer';
        cell.addEventListener('pointerdown', () => {
          if (!DETAIL_TARGET_ID_SET.has(cell.id)) return;
          hideSvgStrokesReverse({ instant: true });
        });
        cell.addEventListener('click', (event) => {
          event.stopPropagation();
          const columnIndex = getColumnIndexForCell(cell);
          const rowIndex = getRowIndexForCell(cell);
          if (columnIndex === -1 || rowIndex === -1) return;
          const isSameCell = expandedColumn === columnIndex && expandedRow === rowIndex && expandedArticle === cell;
          if (isSameCell) {
            resetFocus();
            return;
          }
          openDetail(cell);
          applyFocus(cell, columnIndex, rowIndex);
        });
      });

      document.addEventListener('click', () => {
        if (expandedColumn !== -1 || expandedRow !== -1) resetFocus();
      });

      window.addEventListener('resize', () => {
        const width = window.innerWidth || document.documentElement.clientWidth || 0;
        const height = window.innerHeight || document.documentElement.clientHeight || 0;
        const prevWidth = focusAnimation.viewportWidth ?? width;
        const prevHeight = focusAnimation.viewportHeight ?? height;
        const widthDiff = Math.abs(width - prevWidth);
        const heightDiff = Math.abs(height - prevHeight);
        if (widthDiff < 1 && heightDiff <= 160) {
          focusAnimation.viewportWidth = width;
          focusAnimation.viewportHeight = height;
          return;
        }

        const wasExpanded = expandedColumn !== -1 && expandedRow !== -1;
        const prevColumn = expandedColumn;
        const prevRow = expandedRow;
        const prevArticle = expandedArticle;
        resetFocus(true);
        measureBaseState();
        focusAnimation.viewportWidth = width;
        focusAnimation.viewportHeight = height;
        if (wasExpanded && prevArticle && gridEl.contains(prevArticle)) {
          const columnCount = focusAnimation.baseColumns.length;
          const rowCount = focusAnimation.baseRows.length;
          if (columnCount && rowCount) {
            const safeColumn = Math.min(prevColumn, columnCount - 1);
            const safeRow = Math.min(prevRow, rowCount - 1);
            openDetail(prevArticle);
            applyFocus(prevArticle, safeColumn, safeRow);
          }
        }
      });

      measureBaseState();
    })();

    // === グリッド境界線を自動抽出して描く ===
    function buildGridStrokes({
      order = 'row-major',       // 'row-major' = 上→下, 左→右
      baseDelay = 200,           // 開始ディレイ(ms)
      stepDelay = 90,            // セグメント間ディレイ(ms)
      msPerPx = 1.4,             // 1pxあたりの描画時間(ms) → 長い線ほどゆっくり
      epsilon = 2,               // 隣接判定の許容誤差(px)
      force = false              // レイアウト変更時など強制描画
    } = {}) {
      const root = document.querySelector('.page');
      const grid = document.querySelector('.grid5x3');
      if (!root || !grid) return;
      if (svgStrokesHidden) return;

      const viewportWidth = Math.round(window.innerWidth || document.documentElement.clientWidth || 0);
      const viewportHeight = Math.round(window.innerHeight || document.documentElement.clientHeight || 0);
      const lastWidth = buildGridStrokes._lastWidth;
      const lastHeight = buildGridStrokes._lastHeight;
      const orientationType = (window.screen && window.screen.orientation && typeof window.screen.orientation.type === 'string')
        ? window.screen.orientation.type
        : (viewportWidth >= viewportHeight ? 'landscape' : 'portrait');
      const lastOrientation = buildGridStrokes._lastOrientation;

      if (!force && typeof lastWidth === 'number' && typeof lastHeight === 'number') {
        const widthDiff = Math.abs(viewportWidth - lastWidth);
        const heightDiff = Math.abs(viewportHeight - lastHeight);
        const orientationChanged = lastOrientation && lastOrientation !== orientationType;
        const heightOnlyResize = widthDiff < 1 && heightDiff > 0 && heightDiff <= 160;
        if (!orientationChanged && heightOnlyResize) {
          buildGridStrokes._lastWidth = viewportWidth;
          buildGridStrokes._lastHeight = viewportHeight;
          buildGridStrokes._lastOrientation = orientationType;
          return;
        }
      }

      // 既存の層を作り直し
      const old = root.querySelector('.svg-strokes');
      if (old) old.remove();
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.classList.add('svg-strokes');
      root.appendChild(svg);

      const rr = root.getBoundingClientRect();
      const gr = grid.getBoundingClientRect();

      // 対象セル（.cell）を取得
      const cells = Array.from(grid.querySelectorAll('.cell')).filter(el => el.offsetParent);

      // 相対rect取得（root座標系へ）
      const R = cells.map(el => {
        const r = el.getBoundingClientRect();
        return {
          el,
          left: r.left - rr.left,
          right: r.right - rr.left,
          top: r.top - rr.top,
          bottom: r.bottom - rr.top
        };
      });

      const H = [], V = []; // 水平・垂直の境界候補
      for (let i = 0; i < R.length; i++) {
        for (let j = i + 1; j < R.length; j++) {
          const a = R[i], b = R[j];

          // 水平境界（上下に接する）
          {
            const overlapX1 = Math.max(a.left, b.left);
            const overlapX2 = Math.min(a.right, b.right);
            if (overlapX2 - overlapX1 > 1) {
              const dy1 = Math.abs(a.bottom - b.top);
              const dy2 = Math.abs(b.bottom - a.top);
              if (dy1 <= epsilon) {
                H.push({ y: (a.bottom + b.top) / 2, x1: overlapX1, x2: overlapX2 });
              } else if (dy2 <= epsilon) {
                H.push({ y: (b.bottom + a.top) / 2, x1: overlapX1, x2: overlapX2 });
              }
            }
          }
          // 垂直境界（左右に接する）
          {
            const overlapY1 = Math.max(a.top, b.top);
            const overlapY2 = Math.min(a.bottom, b.bottom);
            if (overlapY2 - overlapY1 > 1) {
              const dx1 = Math.abs(a.right - b.left);
              const dx2 = Math.abs(b.right - a.left);
              if (dx1 <= epsilon) {
                V.push({ x: (a.right + b.left) / 2, y1: overlapY1, y2: overlapY2 });
              } else if (dx2 <= epsilon) {
                V.push({ x: (b.right + a.left) / 2, y1: overlapY1, y2: overlapY2 });
              }
            }
          }
        }
      }

      // 同一直線上の連続セグメントを結合（＝横二連小セルの下線を1本に）
      function merge(list, ori) {
        const groups = new Map();
        const key = s => ori === 'H' ? Math.round(s.y * 2) / 2 : Math.round(s.x * 2) / 2;
        for (const s of list) {
          const k = key(s);
          if (!groups.has(k)) groups.set(k, []);
          groups.get(k).push(s);
        }
        const out = [];
        for (const [_, segs] of groups) {
          segs.sort(ori === 'H' ? (a, b) => a.x1 - b.x1 : (a, b) => a.y1 - b.y1);
          let cur = { ...segs[0] };
          for (let i = 1; i < segs.length; i++) {
            const n = segs[i];
            if (ori === 'H' ? n.x1 <= cur.x2 + 1.1 : n.y1 <= cur.y2 + 1.1) {
              if (ori === 'H') cur.x2 = Math.max(cur.x2, n.x2); else cur.y2 = Math.max(cur.y2, n.y2);
            } else { out.push(cur); cur = { ...n }; }
          }
          out.push(cur);
        }
        return out;
      }
      const Hm = merge(H, 'H');
      const Vm = merge(V, 'V');

      // アニメ順序：row-major（上→下、左→右）
      const segs = [
        ...Hm.map(s => ({ type: 'H', ...s })),
        ...Vm.map(s => ({ type: 'V', ...s })),
      ].sort((a, b) => {
        const ay = (a.type === 'H' ? a.y : a.y1), by = (b.type === 'H' ? b.y : b.y1);
        if (order === 'row-major') {
          return (ay - by) || ((a.type === 'H' ? a.x1 : a.x) - (b.type === 'H' ? b.x1 : b.x));
        } else { // col-major
          const ax = (a.type === 'H' ? a.x1 : a.x), bx = (b.type === 'H' ? b.x1 : b.x);
          return (ax - bx) || (ay - by);
        }
      });

      // パス生成＋長さベースの描画
      let maxEndTime = 0;
      segs.forEach((s, i) => {
        const p = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        let length = 0;

        if (s.type === 'H') {
          const y = Math.round(s.y) + .5;
          const x1 = Math.round(s.x1) + .5, x2 = Math.round(s.x2) - .5;
          length = Math.max(0, x2 - x1);
          if (length <= 0) return;
          p.setAttribute('d', `M ${x1} ${y} L ${x2} ${y}`);
        } else {
          const x = Math.round(s.x) + .5;
          const y1 = Math.round(s.y1) + .5, y2 = Math.round(s.y2) - .5;
          length = Math.max(0, y2 - y1);
          if (length <= 0) return;
          p.setAttribute('d', `M ${x} ${y1} L ${x} ${y2}`);
        }
        const duration = Math.max(240, length * msPerPx);
        const delay = baseDelay + i * stepDelay;
        const endTime = delay + duration;
        if (endTime > maxEndTime) maxEndTime = endTime;
        p.dataset.strokeDuration = String(duration);
        p.dataset.strokeDelay = String(delay);
        p.dataset.strokeLength = String(length);
        p.style.strokeDasharray = length;
        p.style.strokeDashoffset = length;
        p.style.animation = `draw-stroke ${duration}ms ease ${delay}ms forwards`;
        svg.appendChild(p);
      });

      // サイドバー右端を「上→下」に1本描画
      const sidebar = document.querySelector('.sidebar');
      if (sidebar) {
        const sr = sidebar.getBoundingClientRect();
        const x = Math.round(sr.right - rr.left) + .5;
        const y1 = Math.round(sr.top - rr.top) + .5;
        const y2 = Math.round(sr.bottom - rr.top) - .5;
        const p = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        p.setAttribute('d', `M ${x} ${y1} L ${x} ${y2}`);
        const len = y2 - y1;
        if (len > 0) {
          const duration = Math.max(240, len * msPerPx);
          const delay = 100;
          const endTime = delay + duration;
          if (endTime > maxEndTime) maxEndTime = endTime;
          p.dataset.strokeDuration = String(duration);
          p.dataset.strokeDelay = String(delay);
          p.dataset.strokeLength = String(len);
          p.style.strokeDasharray = len;
          p.style.strokeDashoffset = len;
          p.style.animation = `draw-stroke ${duration}ms ease ${delay}ms forwards`;
          svg.appendChild(p);
        }
      }
      svg.dataset.strokeTimeline = String(maxEndTime);

      buildGridStrokes._lastWidth = viewportWidth;
      buildGridStrokes._lastHeight = viewportHeight;
      buildGridStrokes._lastOrientation = orientationType;
    }

    // 初回＆リサイズで実行（フォントロード後に）
    window.addEventListener('load', () => buildGridStrokes(), { once: true });
    addEventListener('resize', () => { clearTimeout(buildGridStrokes._t); buildGridStrokes._t = setTimeout(() => buildGridStrokes(), 120); }, { passive: true });

  </script>
</body>

</html>
